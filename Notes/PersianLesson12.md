# مقیاس‌پذیری فراکتالی در اتریوم

مقیاس‌پذیری فراکتالی یک رویکرد نوظهور برای دستیابی به مقیاس‌پذیری عظیم در اتریوم است که با ساخت لایه‌های متوالی روی یکدیگر اجرا می‌شود. این راهنما مفاهیم کلیدی، محدودیت‌ها و کاربردهای مرتبط با لایه سوم (L3)، زنجیره‌های برنامه (App Chains)، و زیرساخت‌های رول‌آپ مدرن را بررسی می‌کند.
![fractal](./images/L12image01.jpeg)
---

## مفاهیم اصلی

### رول‌آپ‌ها چگونه مقیاس‌پذیری ایجاد می‌کنند

- رول‌آپ‌ها با **اجرای تراکنش‌ها خارج از لایه ۱ (L1)**، مقیاس‌پذیری را افزایش می‌دهند.
- آن‌ها داده یا اثبات‌ها را فشرده‌سازی کرده و در L1 منتشر می‌کنند، که امنیت **در حد اتریوم** را تضمین می‌کند.
- این رویکرد موجب کاهش هزینه گس و افزایش توان عملیاتی می‌شود.

### محدودیت‌های لایه‌بندی

- روی‌هم‌چیدن لایه‌ها (مثلاً L3 → L2 → L1) به **مقیاس‌پذیری بی‌نهایت** منجر نمی‌شود.
- هر لایه در نهایت باید **داده‌ها** یا **اثبات اعتبار** را در L1 منتشر کند.
- این انتشارها **هزینه گس غیر صفر** دارند که یک کف هزینه‌ای ایجاد می‌کند.
- یک L3 داده‌هایش را به L2 والد خود ارسال می‌کند که آن نیز به L1 می‌فرستد، و این موجب **نیازهای متوالی به دسترسی داده** می‌شود.

### دسترسی به داده بسیار حیاتی است

- همان‌طور که L2ها باید دسترسی به داده‌ها را برای L1 تضمین کنند، L3ها نیز باید داده‌های حالت خود را **برای L2 والدشان در دسترس** قرار دهند.
- بدون دسترسی به داده، نمی‌توان اعتبار حالت را تأیید کرد.

---

## هدف از لایه سوم (L3)

سه مدل استراتژیک برای بهره‌گیری از L3ها وجود دارد:

### 1. L3 برای قابلیت‌های سفارشی‌شده

- **مفهوم**: L2 مقیاس‌پذیری عمومی فراهم می‌کند، L3 ویژگی‌های خاصی اضافه می‌کند.
- **کاربرد**: تراکنش‌های مبتنی بر حریم خصوصی با استفاده از اثبات‌های ZK.
- **مثال**: کاربران وجوه را از L2 به یک L3 خصوصی منتقل کرده، اقدامات محرمانه انجام می‌دهند، سپس به L2 بازمی‌گردند.

### 2. L3 برای مقیاس‌پذیری اختصاصی

- **مفهوم**: L3های اختصاصی از تداخل سایر اپلیکیشن‌ها جلوگیری می‌کنند.
- **کاربرد**: معاملات با فرکانس بالا یا بازی‌های بزرگ‌مقیاس که نیاز به تأخیر کم دارند.
- **مثال**: یک L3 با زمان‌های بلاک سریع‌تر و مکانیسم‌های گس خاص برای یک برنامه.

### 3. L3 برای مقیاس‌پذیری با اعتماد کم (ولی‌دیوم‌ها)

- **مفهوم**: مقداری از بی‌اعتمادی را فدای **هزینه و عملکرد بهتر** می‌کنند.
- **کاربرد**: ولی‌دیوم‌هایی با داده‌های خارج از زنجیره که توسط کمیته دسترسی به داده (DAC) مدیریت می‌شوند.
- **ریسک**: اگر DAC داده‌ها را منتشر نکند، کاربران ممکن است دسترسی به وجوه خود را از دست بدهند.
- **مثال**: ولی‌دیوم‌هایی با اثبات ZK بدون انتشار داده در زنجیره.

---

## درک زنجیره‌های برنامه (App Chains)

### تعریف

- یک **زنجیره برنامه** بلاک‌چینی است که **برای یک اپلیکیشن خاص** طراحی شده است.
- می‌تواند L2 یا L3 باشد، بسته به جایگاهش در پشته.

### هدف

- **کنترل حاکمیتی** بر عملکرد، فضای بلاک، و مدیریت.
- اقتصاد توکنی، اجماع، و زیرساخت قابل سفارشی‌سازی.

### پیاده‌سازی

- یک استاندارد فنی سخت‌گیرانه نیست — بیشتر عملکرد را توصیف می‌کند تا فرم را.
- می‌تواند در L1 (به عنوان L2) یا در L2 (به عنوان L3) تسویه شود.

---

## مقایسه L3 و زنجیره برنامه

| ویژگی          | لایه سوم (Layer 3)                             | زنجیره برنامه (App Chain)                            |
|----------------|------------------------------------------------|-------------------------------------------------------|
| تعریف          | بلاک‌چینی که روی یک لایه دوم تسویه می‌شود     | بلاک‌چین اختصاصی برای یک اپلیکیشن خاص               |
| هدف اصلی       | مقیاس‌پذیری بسیار بالا یا ویژگی‌های خاص       | حاکمیت کامل بر منابع و محیط                         |
| پیاده‌سازی     | عمومی یا اپلیکیشن-محور                        | قابل پیاده‌سازی به صورت L2 یا L3                     |
| مثال           | L3 بازی که روی آربیتروم تسویه می‌شود         | زنجیره اختصاصی بازی که به عنوان یک L3 ساخته شده     |

---

## وضعیت فعلی: فریم‌ورک‌ها و پیاده‌سازی‌های رول‌آپ

پیشرفت L3ها و App Chainها به‌سرعت در حال رشد است، به لطف پلتفرم‌های **رول‌آپ به‌عنوان سرویس (RaaS)** و **فریم‌ورک‌های متن‌باز**.

### Arbitrum Orbit

- راه‌اندازی زنجیره‌های L3 سفارشی روی Arbitrum L2.
- قابل سفارشی‌سازی:
  - هزینه گس
  - توان عملیاتی
  - مجوزها

### OP Stack

- نیروی محرکه اکوسیستم Optimism.
- راه‌اندازی زنجیره‌های L2/L3 در شبکه **Superchain**.
- مورد استفاده در:
  - **Base**
  - **Zora**

### Polygon CDK (کیت توسعه زنجیره)

- ابزار متن‌باز برای راه‌اندازی **L2های مبتنی بر ZK**.
- قابلیت تعامل از طریق **پل ZK مشترک**.
- بخشی از اکوسیستم رو‌به‌رشد Polygon.

### zkSync Hyperchains

- چشم‌انداز **مقیاس‌پذیری فراکتالی** zkSync.
- توسعه‌دهندگان L3های قابل سفارشی‌سازی را راه‌اندازی می‌کنند.
- این‌ها روی zkSync Era (یک L2) تسویه می‌شوند و امنیت اثبات ZK آن را به ارث می‌برند.

---

# آربیتراژ و لیکوئیدیشن در زنجیره‌های EVM

این راهنما مروری جامع بر مکانیزم‌های آربیتراژ و پیاده‌سازی آن‌ها در بلاک‌چین‌های سازگار با اتریوم (EVM) ارائه می‌دهد، با تمرکز بر اجرای اتمی، وام‌های آنی (Flash Loans)، و استراتژی‌های قرارداد هوشمند.

---

## آربیتراژ در DeFi

**تعریف**: آربیتراژ استفاده از تفاوت قیمت یک دارایی یکسان در بازارهای مختلف برای کسب سود است.

در DeFi، آربیتراژ معمولاً شامل **صرافی‌های غیرمتمرکز (DEX)** مانند Uniswap، SushiSwap، Curve و ... است.

---

### مفهوم اصلی

- **خرید ارزان، فروش گران**: دارایی را از یک DEX با قیمت پایین خریده و در DEX دیگر با قیمت بالاتر بفروشید — ترجیحاً در یک تراکنش.
- **تراکنش واحد**: تمام مراحل به صورت اتمی اجرا می‌شوند. یا همه موفق می‌شوند یا کل تراکنش برگشت می‌خورد.

---

### اجرای اتمی

- تراکنش‌های بلاک‌چین به‌صورت **اتمی** طراحی شده‌اند.
- این ویژگی تضمین می‌کند که آربیتراژکننده‌ها فقط نیمی از عملیات (خرید یا فروش) را اجرا نکرده و با دارایی ناخواسته باقی نمی‌مانند.
- در صورت شکست هر قسمت (مثلاً لغزش قیمت)، **کل تراکنش برگشت داده می‌شود**.

---

### فلش‌لون‌ها و فلش‌سواپ‌ها

- **فلش‌لون‌ها**: توسط پروتکل‌هایی مانند Aave و dYdX ارائه می‌شوند؛ کاربران می‌توانند بدون وثیقه وام بگیرند — اما باید در **همان تراکنش** بازپرداخت شود.
- **فلش‌سواپ‌ها**: قابلیت Uniswap V2 و V3 برای قرض‌گیری توکن در حین سواپ و بازپرداخت در پایان تراکنش.

#### مثال:
- ۱,۰۰۰,۰۰۰ DAI وام بگیرید.
- با آن ETH در Curve بخرید.
- ETH را با DAI بیشتر در Uniswap بفروشید.
- وام + کارمزد را بازپرداخت کنید.
- DAI باقیمانده **سود شماست**.

---

### محیط اجرا

- **بات‌های آربیتراژ**:
  - قیمت DEXها و **ممپول** را برای تراکنش‌های در صف مانیتور می‌کنند.
  - به دنبال **تفاوت قیمت** و **فرصت‌های لغزش** هستند.
- **ابزارهای درون‌زنجیره‌ای**:
  - با استفاده از کتابخانه‌های web3 به قراردادهای DEX متصل می‌شوند.
  - از پروتکل‌های فلش‌لون برای بهره‌وری سرمایه استفاده می‌کنند.
- **ابزارهای برون‌زنجیره‌ای**:
  - مانیتورینگ ممپول، RPC خصوصی، یا **مسیریاب‌های MEV** برای فرانت‌رانینگ و بک‌رانینگ.

---

### منطق قرارداد هوشمند برای آربیتراژ

#### جریان مرحله به مرحله

1. **شروع**:
   - قرارداد آربیتراژ توسط یک حساب خارجی (EOA) فراخوانی می‌شود.
2. **شروع فلش‌لون**:
   - قرارداد از یک پروتکل فلش‌لون یا DEX فلش‌سواپ وام می‌گیرد.
3. **اجرای سواپ‌های DEX**:
   - یک یا چند سواپ توکن در DEXهای مختلف انجام می‌شود.
   - هدف: **دریافت بیشتر از دارایی قرض گرفته‌شده**.
4. **بازپرداخت وام**:
   - مقدار وام و کارمزد آن بازپرداخت می‌شود.
5. **برداشت سود**:
   - سود باقی‌مانده به یک آدرس یا کیف پول خاص منتقل می‌شود.

---

## مثال کد آربیتراژ (مفهومی)

در زیر یک **مثال ساده‌شده** از قرارداد Solidity برای اجرای فلش‌سواپ Uniswap V2 جهت آربیتراژ آمده است:

~~~~solidity
// (کد داخل بلوک‌های ~~~ قرار دارد — تغییر یافته برای حفظ Markdown)

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "./interfaces/ISushiSwapRouter.sol";

contract Arbitrageur is IUniswapV2Callee {
    // ... بقیه قرارداد مشابه متن اصلی باقی می‌ماند ...
}
~~~~

---

# لیکوئیدیشن در پروتکل‌های وام‌دهی DeFi

لیکوئیدیشن یک فرایند حیاتی در پلتفرم‌های وام‌دهی غیرمتمرکز است. این فرآیند با فروش وثیقه کاربر در صورت کاهش نسبت ایمنی وام، موجب حفظ سلامت سیستم می‌شود.

---

**لیکوئیدیشن چیست؟**

**تعریف**: وقتی ارزش وثیقه کاربر خیلی نزدیک یا پایین‌تر از مقدار وام شود، سیستم برای جلوگیری از بدهی معوق، وثیقه را می‌فروشد.

مکانیزمی ضروری برای محافظت از پروتکل‌هایی مانند **Aave** و **Compound** در برابر بدهی‌های بد.

---

## فاکتور سلامت (Health Factor)

عدد عددی برای سنجش ایمنی موقعیت وام کاربر.

- **فرمول**:
$$
\frac{
\sum (\text{ارزش وثیقه} \times \text{آستانه لیکوئیدیشن})
}{
\sum \text{ارزش وام گرفته‌شده}
}
$$

- **تفسیر**:
  - اگر **> 1** → موقعیت ایمن است.
  - اگر **< 1** → واجد شرایط لیکوئیدیشن.

---

## آستانه لیکوئیدیشن

هر دارایی یک آستانه دارد — درصدی از ارزش آن می‌تواند وام گرفته شود.

- **مثال**:
  - اگر آستانه برای ETH، **۸۰٪** باشد، از هر ۱ ETH فقط می‌توان ۰.۸ ETH وام گرفت.
  - بیشتر از آن → لیکوئیدیشن.

---

## لیکوئیدیتورها

- کاربران (یا بات‌هایی) که موقعیت‌های ناسالم را شناسایی و فرآیند را آغاز می‌کنند.
- انگیزه آن‌ها **پاداش لیکوئیدیشن** است.

---

## فرایند لیکوئیدیشن: مرحله به مرحله

1. لیکوئیدیتور موقعیت با Health Factor < 1 را شناسایی می‌کند.
2. فراخوانی تابع قرارداد (مثلاً `liquidationCall()` در Aave).
3. مشخص‌کردن:
   - آدرس کاربر
   - مقدار بدهی
4. در عوض:
   - بخشی از وثیقه کاربر به لیکوئیدیتور داده می‌شود.
   - با **تخفیف** = **پاداش لیکوئیدیشن**.

---

## پاداش لیکوئیدیشن

- پاداشی برای لیکوئیدیتورها.
- درصدی از مبلغ وام بازپرداخت‌شده.
- **مثال**:
  - بازپرداخت $۱,۰۰۰
  - دریافت $۱,۰۵۰ وثیقه

---

## رابط قرارداد هوشمند

پروتکل‌های وام‌دهی توابع عمومی برای **لیکوئیدیشن بدون نیاز به مجوز** دارند.

- مسئولیت‌ها:
  - اعتبارسنجی شرایط لیکوئیدیشن
  - انتقال مبلغ بازپرداخت
  - انتقال وثیقه تخفیف‌خورده
  - به‌روزرسانی وضعیت پروتکل

---

## مثال کد لیکوئیدیشن (مفهومی)

در ادامه یک نمونه مفهومی قرارداد Solidity برای اجرای لیکوئیدیشن در یک پروتکل مانند Aave آورده شده است:

~~~~solidity
// (کد داخل بلوک‌های ~~~ قرار دارد — تغییر یافته برای حفظ Markdown)

import "./interfaces/ILendingPool.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Liquidator {
    ILendingPool lendingPool;
    address owner;

    constructor(address _lendingPoolAddress) {
        lendingPool = ILendingPool(_lendingPoolAddress);
        owner = msg.sender;
    }

    // Function to execute a liquidation
    // Assumes this contract already holds the debt asset (e.g., DAI) needed for repayment
    function executeLiquidation(
        address collateralAsset,
        address debtAsset,
        address userToLiquidate,
        uint debtToCover,
        bool receiveAToken
    ) external {
        // 1. Approve the Lending Pool to pull the debt asset from this contract
        IERC20(debtAsset).approve(address(lendingPool), debtToCover);

        // 2. Call the liquidation function on the Lending Pool contract
        // This function will:
        // - Pull 'debtToCover' amount of 'debtAsset' from this liquidator contract.
        // - In exchange, it sends the liquidator a discounted amount of the 'collateralAsset'.
        // - The 'receiveAToken' boolean determines if you get the raw collateral or the protocol's aToken.
        lendingPool.liquidationCall(
            collateralAsset,
            debtAsset,
            userToLiquidate,
            debtToCover,
            receiveAToken
        );
    }
    
    // Helper function to withdraw profits
    function withdraw(address tokenAddress) external {
        require(msg.sender == owner, "Only owner can withdraw");
        IERC20 token = IERC20(tokenAddress);
        token.transfer(owner, token.balanceOf(address(this)));
    }
}

~~~~
