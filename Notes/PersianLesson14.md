
<div dir="rtl">

# معرفی Ethers.js

**Ethers.js** یک کتابخانه سبک و جامع جاوااسکریپت برای تعامل با بلاکچین اتریوم است. این کتابخانه به طور گسترده‌ای برای ساخت اپلیکیشن‌های غیرمتمرکز (dApp) ایمن و سمت کاربر مورد استفاده قرار می‌گیرد. نسخه **v6** این کتابخانه، تغییرات معماری مهمی را معرفی می‌کند که با هدف افزایش ماژولار بودن، امنیت و شفافیت در طراحی اپلیکیشن‌ها انجام شده است.

---

## معماری اصلی: تفکیک وظایف

Ethers.js بر پایه سه انتزاع اصلی ساخته شده است:

1. **Provider** – برای خواندن داده‌ها از بلاکچین.
2. **Signer** – برای ارسال تراکنش‌ها و نوشتن داده‌ها بر روی بلاکچین.
3. **Contract** – یک انتزاع سطح بالاتر که با ترکیب `Provider` و `Signer` امکان تعامل راحت با قراردادهای هوشمند را فراهم می‌کند.

این تفکیک سخت‌گیرانه به توسعه‌دهندگان کمک می‌کند تا از ارتقاء ناخواسته سطح دسترسی جلوگیری کرده و معماری dAppها را به شکل **امن از طراحی** پیش ببرند.

---

## Provider: دسترسی فقط-خواندنی به بلاکچین

### Provider چیست؟

در Ethers.js، **Provider** یک اتصال فقط‌خواندنی به یک بلاکچین سازگار با EVM است. این امکان را به کاربران می‌دهد تا **اطلاعات بلاکچین را واکشی کنند** بدون اینکه کلید خصوصی را افشا کرده یا تغییری در وضعیت شبکه ایجاد کنند.

Provider مرز روشنی بین عملیات‌های **خواندن** و **نوشتن** ایجاد می‌کند و بدین ترتیب سطح حملات احتمالی را کاهش می‌دهد.

### موارد استفاده

یک `Provider` برای عملیات‌هایی مانند زیر استفاده می‌شود:

- **دریافت شماره بلاک فعلی**  
  ~~~javascript
  provider.getBlockNumber()
  ~~~

- **بررسی موجودی ETH یک حساب**  
  ~~~javascript
  provider.getBalance(addressOrEnsName)
  ~~~

- **فراخوانی توابع فقط‌خواندنی (view/pure) قراردادهای هوشمند**

- **واکشی لاگ‌های رویدادهای گذشته**  
  ~~~javascript
  provider.getLogs(filter)
  ~~~

  با این حال، برای واکشی رویدادها به صورت ساختاریافته، روش زیر ترجیح داده می‌شود:  
  ~~~javascript
  contract.queryFilter(eventFilter)
  ~~~

### فلسفه طراحی

با الزام توسعه‌دهندگان به استفاده از `Provider` برای تمام عملیات‌های خواندنی و `Signer` فقط برای عملیات‌های نوشتنی، Ethers.js دسترسی با **کمترین سطح دسترسی لازم** را ترویج می‌دهد و احتمال تغییر ناخواسته یا مخرب در وضعیت شبکه را کاهش می‌دهد.

یک معماری dApp بهینه:

- از `Provider` به عنوان رابط پیش‌فرض استفاده می‌کند.
- فقط زمانی به `Signer` سوئیچ می‌کند که کاربر **صراحتاً یک تراکنش را آغاز کند**.

---

## ایجاد Provider در نسخه v6 Ethers.js

### محیط‌های مرورگر (مثلاً MetaMask)

در نسخه v6، Ethers.js کلاس `BrowserProvider` را برای تعامل با کیف پول‌های مرورگر مانند MetaMask معرفی کرده است.

این کلاس جایگزین `Web3Provider` در نسخه v5 شده و نامی دقیق‌تر و توصیفی‌تر دارد.

#### مثال:

~~~javascript
// نسخه v6: اتصال به کیف پول مرورگر مانند MetaMask
import { ethers } from "ethers";

let provider;
if (typeof window.ethereum === "undefined") {
    // اگر کیف پول مرورگر نصب نشده باشد
    // استفاده از provider پیش‌فرض برای برنامه‌های تولیدی توصیه نمی‌شود
    // به دلیل محدودیت نرخ و نبود زیرساخت اختصاصی،
    // اما برای تست سریع و اسکریپت‌های ساده مفید است.
    console.log("کیف پول مرورگر نصب نشده است؛ استفاده از provider فقط‌خواندنی پیش‌فرض.");
    provider = ethers.getDefaultProvider("mainnet");
} else {
    // اتصال به provider تزریق‌شده بر اساس EIP-1193
    provider = new ethers.BrowserProvider(window.ethereum);
}
~~~

---

## خلاصه

| مؤلفه   | هدف                                 | سطح دسترسی                  |
|----------|-------------------------------------|-----------------------------|
| Provider | خواندن وضعیت بلاکچین               | فقط‌خواندنی (Read-only)     |
| Signer   | نوشتن در بلاکچین (تراکنش‌ها)       | نیازمند امضا                |
| Contract | رابط تعامل با قراردادهای هوشمند (خواندن/نوشتن بسته به Provider یا Signer) | خواندنی یا نوشتنی بر اساس تنظیمات |

`Provider` پایه و اساس تعامل ایمن با بلاکچین اتریوم است، بنابراین درک صحیح و استفاده مناسب از آن هنگام ساخت dApp با Ethers.js بسیار حیاتی است.

---


# محیط‌های Backend/Node.js در Ethers.js

در محیط‌های Backend یا Node.js، جایی که مرورگر یا ارائه‌دهنده تزریق‌شده (مثل MetaMask) وجود ندارد، روش مناسب برای اتصال به شبکه Ethereum استفاده از **JsonRpcProvider** است.

---

## JsonRpcProvider: دسترسی مستقیم به بلاک‌چین

### JsonRpcProvider چیست؟

کلاس `JsonRpcProvider` در Ethers.js به یک اسکریپت بک‌اند یا اپلیکیشن سرور اجازه می‌دهد تا با استفاده از پروتکل **JSON-RPC**، یک **اتصال مستقیم** به یک نود Ethereum برقرار کند. این نود می‌تواند:

- یک ارائه‌دهنده عمومی RPC مانند **Alchemy**، **Infura** یا **Ankr** باشد.
- یک نود محلی توسعه‌یافته مانند **Hardhat**، **Anvil** یا **Geth** باشد.

این روش برای موارد زیر ایده‌آل است:

- dAppهای سمت سرور
- اسکریپت‌ها و بات‌های خودکار
- مجموعه‌های تست بک‌اند
- سرویس‌های زیرساختی

## مثال: اتصال به یک نود عمومی Ethereum

~~~~javascript
import { JsonRpcProvider } from "ethers";

// استفاده از Infura
const provider = new JsonRpcProvider("https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID");

// استفاده از Alchemy
const provider = new JsonRpcProvider("https://eth-mainnet.g.alchemy.com/v2/YOUR_ALCHEMY_API_KEY");
~~~~

---

## خلاصه

| کلاس                | محیط              | هدف                                             |
|---------------------|--------------------|--------------------------------------------------|
| `JsonRpcProvider`   | Backend/Node.js    | اتصال به نودهای Ethereum از طریق JSON-RPC       |
| `BrowserProvider`   | فرانت‌اند (وب)    | بسته‌بندی ارائه‌دهنده EIP-1193 تزریق‌شده (مثل MetaMask) |

`JsonRpcProvider` ابزار استاندارد برای هر سیستم بک‌اند است که به دسترسی مستقیم و قابل‌اعتماد به داده‌های Ethereum و قابلیت‌های تراکنش نیاز دارد.

---

# Signer: انتزاع حساب و دسترسی نوشتنی

در Ethers.js، یک **Signer** یک انتزاع اساسی است که برای انجام **عملیات نوشتنی** روی بلاک‌چین استفاده می‌شود. در حالی که یک `Provider` فقط **دسترسی خواندنی** فراهم می‌کند، یک `Signer` به شما امکان می‌دهد تا **تراکنش‌ها را امضا و ارسال کنید**، با قراردادهایی که وضعیت را تغییر می‌دهند تعامل داشته باشید و پیام‌ها را امضا کنید — بدون افشای کلید خصوصی.

## Signer چیست؟

یک **Signer** نمایانگر یک حساب Ethereum است که قابلیت‌های زیر را دارد:

- امضای تراکنش‌ها (برای تغییر وضعیت بلاک‌چین)
- امضای پیام‌ها (برای احراز هویت یا تأیید)
- تعامل با قراردادهای هوشمندی که به تغییر وضعیت نیاز دارند

با این حال، به برنامه شما دسترسی مستقیم به **کلید خصوصی** کاربر نمی‌دهد. در عوض، امضا را به یک محیط امن کیف پول مثل MetaMask یا یک کیف پول سازگار با EIP-1193 واگذار می‌کند.

---

## چرا این مهم است؟

این جداسازی بین برنامه و کلید خصوصی کاربر یک **بهترین شیوه امنیتی** است. نحوه کار آن در مرورگر به این صورت است:

- زمانی که از `provider.getSigner()` در `BrowserProvider` استفاده می‌کنید، کیف پول مرورگر از کاربر می‌خواهد که اتصال را تأیید کند.
- پس از اتصال، dApp می‌تواند درخواست‌های امضا برای آن حساب ارسال کند.
- کیف پول از کاربر می‌خواهد که هر عملیات را تأیید کند، بنابراین کنترل در دست کاربر باقی می‌ماند.

این معماری به dAppها امکان می‌دهد تا **بدون نیاز به ذخیره یا مدیریت کلیدهای خصوصی** به صورت ایمن با Ethereum تعامل داشته باشند.

---

## توابع کلیدی یک Signer

در اینجا موارد استفاده رایج و توابع متناظر در Ethers.js آمده است:

- **ارسال یک تراکنش**  
  ارسال یک تراکنش به شبکه Ethereum که وضعیت را تغییر می‌دهد (مثلاً انتقال ETH یا فراخوانی یک تابع قرارداد هوشمند).

  ~~~~javascript
  signer.sendTransaction(txObject)
  ~~~~

- **امضای یک پیام ساده (EIP-191)**  
  استفاده در احراز هویت خارج از زنجیره یا اثبات مالکیت یک آدرس.

  ~~~~javascript
  signer.signMessage("Hello, Ethereum!")
  ~~~~

- **امضای داده ساختاریافته تایپ‌شده (EIP-712)**  
  کاربردی در برنامه‌های DeFi، DAOها و کیف پول‌هایی که نیاز به امضای داده‌های ساختاریافته دارند.

  ~~~~javascript
  signer.signTypedData(domain, types, message)
  ~~~~

- **تعامل با قراردادهای هوشمند (نوشتنی)**  
  برای اجرای توابعی که وضعیت قرارداد را تغییر می‌دهند.

---

# کار با Signer در Ethers.js نسخه ۶

## معرفی

یک `Signer` در Ethers.js برای امضای پیام‌ها و تراکنش‌ها از طرف کاربر استفاده می‌شود. تقریباً همیشه از یک نمونه `Provider` گرفته می‌شود. این راهنما دو روش اصلی برای دریافت signer را توضیح می‌دهد: از طریق کیف پول مرورگر با استفاده از `BrowserProvider` و از طریق کلید خصوصی با استفاده از کلاس `Wallet`.

---

## از BrowserProvider

فراخوانی `provider.getSigner()` با استفاده از `BrowserProvider` باعث می‌شود که کیف پول مرورگر (مثلاً MetaMask) از کاربر بخواهد حساب خود را متصل کند. پس از اتصال، برنامه می‌تواند درخواست امضا برای آن حساب ارسال کند.

~~~~javascript
// نسخه ۶: گرفتن یک Signer از کیف پول مرورگر
const provider = new ethers.BrowserProvider(window.ethereum);

// اگر کیف پول قبلاً متصل نشده باشد، این دستور از کاربر می‌خواهد که آن را متصل کند.
const signer = await provider.getSigner();
const address = await signer.getAddress();
console.log("Signer Address:", address);
~~~~

---

## از کلید خصوصی (Wallet)

کلاس `Wallet` یک پیاده‌سازی واقعی از `Signer` است که کلید خصوصی را مستقیماً در حافظه نگه می‌دارد. این روش برای اسکریپت‌های بک‌اند، برنامه‌های سرور یا سناریوهای تست خودکار بسیار مفید است.

> **نکته امنیتی مهم:** استفاده از کلاس `Wallet` در برنامه‌های فرانت‌اند به‌شدت ناامن است، زیرا کلید خصوصی را در کد سمت کلاینت افشا می‌کند.

~~~~javascript
// نسخه ۶: ایجاد یک نمونه Wallet (نوعی از Signer) برای استفاده در بک‌اند
import { ethers } from "ethers";

const provider = new ethers.JsonRpcProvider(ALCHEMY_MAINNET_URL);

// این کلید خصوصی باید محرمانه و امن نگه داشته شود، معمولاً از متغیر محیطی بارگذاری می‌شود.
// هرگز آن را در برنامه‌های فرانت‌اند افشا نکنید یا به کنترل نسخه اضافه نکنید.
const privateKey = process.env.SERVER_WALLET_PRIVATE_KEY;
const wallet = new ethers.Wallet(privateKey, provider);
~~~~

---

## ایجاد یک شیء قرارداد (Contract)

برای ایجاد یک نمونه از Contract، به سه بخش اساسی نیاز دارید:

1. **آدرس قرارداد**  
   آدرس روی زنجیره‌ای که قرارداد هوشمند در آن مستقر شده است.

2. **ABI قرارداد**  
   توصیف فرمت JSON از رابط عمومی قرارداد که توسط کامپایلر Solidity تولید می‌شود.  
   - Ethers.js همچنین از فرمت مختصرتر **Human-Readable ABI** پشتیبانی می‌کند.

3. **Runner (Provider یا Signer)**  
   این آرگومان سوم تعیین می‌کند که نمونه قرارداد چه عملیاتی را می‌تواند انجام دهد:  
   - اگر **Provider** داده شود، نمونه قرارداد فقط **خواندنی** است (فقط می‌تواند داده بلاک‌چین را بخواند).  
   - اگر **Signer** داده شود، نمونه قرارداد می‌تواند **تراکنش‌های تغییر وضعیت** را اجرا کند (ارسال تراکنش).

---
# تعامل با قرارداد هوشمند

برای توسعه‌دهندگان Solidity، هدف اصلی از یک کتابخانه سمت کلاینت، فراخوانی توابع قرارداد هوشمند مستقر شده است.

## نمونه‌سازی یک قرارداد

روش استاندارد برای ایجاد یک نمونه قرارداد استفاده از سازنده‌ی `ethers.Contract` است. قابلیت‌های این نمونه با توجه به **runner** (آرگومان سوم) تعیین می‌شود.

## نمونه فقط‌خواندنی

- با ارائه‌ی یک **Provider**، نمونه‌ای ایجاد می‌کنید که فقط می‌تواند توابع **view** و **pure** را فراخوانی کند.
- این حالت امن‌ترین گزینه برای نمایش داده‌ها است.

## نمونه‌های قابل‌نوشتن

### مقدمه

در هنگام تعامل با قراردادهای هوشمند با استفاده از Ethers.js، می‌توانید دو نوع نمونه قرارداد ایجاد کنید:

- **نمونه فقط‌خواندنی**: اجازه‌ی فراخوانی توابع `view` یا `pure` که وضعیت بلاک‌چین را تغییر نمی‌دهند.
- **نمونه قابل‌نوشتن**: اجازه‌ی فراخوانی توابعی که وضعیت را تغییر می‌دهند (مثلاً `transfer()`)، که به یک `Signer` نیاز دارد.

### نمونه قابل‌نوشتن

یک نمونه‌ی قابل‌نوشتن با استفاده از یک `Signer` ایجاد می‌شود. این برای ارسال تراکنش‌هایی که وضعیت قرارداد را تغییر می‌دهند الزامی است.

~~~~js
// فرض کنید `signer` از قبل از provider گرفته شده است.
const writeableContract = new ethers.Contract(contractAddress, contractAbi, signer);

// مثال: ارسال یک تراکنش تغییردهنده‌ی وضعیت
await writeableContract.transfer("0xRecipientAddress", ethers.parseUnits("10.0", 18));
~~~~

---

### بهترین روش: استفاده از `.connect()` برای ایجاد یک نمونه موقت قابل‌نوشتن

توصیه می‌شود برای دریافت اولیه داده‌ها با یک نمونه فقط‌خواندنی شروع کنید و فقط در صورت نیاز یک نمونه قابل‌نوشتن ایجاد نمایید.

از متد `.connect()` برای اتصال یک signer به‌صورت موقت و بدون تغییر نمونه اولیه استفاده کنید. این کار به جلوگیری از اثرات جانبی کمک می‌کند.

~~~~js
// شروع با نمونه فقط‌خواندنی
const contract = new ethers.Contract(contractAddress, contractAbi, provider);

// بعداً، وقتی کاربر تراکنشی را فعال می‌کند (مثلاً با کلیک روی دکمه)
const signer = await provider.getSigner();

// ایجاد یک نمونه جدید متصل به signer
const contractWithSigner = contract.connect(signer);

// استفاده از نمونه‌ی متصل‌شده برای ارسال تراکنش
await contractWithSigner.someStateChangingFunction();
~~~~

---

## اجرای توابع فقط‌خواندنی (فراخوانی‌های ثابت)

توابعی که در قرارداد Solidity با `view` یا `pure` علامت‌گذاری شده‌اند، به‌صورت متدهای ناهمگام در نمونه Ethers.js نمایان می‌شوند. فراخوانی این توابع هزینه گس ندارد و فقط از نود متصل‌شده داده‌ها را می‌گیرد.

---

## فراخوانی مستقیم

- این متدها یک **Promise** برمی‌گردانند که به مقدار بازگشتی تابع ختم می‌شود.
- Ethers.js به‌طور خودکار داده‌ی بازگشتی را **از حالت سریال خارج** کرده و به نوع مناسب **تبدیل** می‌کند.

---

### مثال‌هایی از تبدیل نوع داده

- `uint256` در Solidity به **BigInt** در JavaScript تبدیل می‌شود.
- `string` در Solidity به **رشته** در JavaScript تبدیل می‌شود.
- `address` در Solidity به **رشته آدرس checksum شده** در JavaScript تبدیل می‌شود.

~~~~javascript
// فرض بر این است که یک نمونه ERC-20 فقط‌خواندنی داریم (`readOnlyContract`).

// Solidity: function name() public view returns (string memory);
const tokenName = await readOnlyContract.name();
// مقدار `tokenName` یک رشته خواهد بود، مثلاً "MyToken".

// Solidity: function totalSupply() public view returns (uint256);
const totalSupply = await readOnlyContract.totalSupply();
// مقدار `totalSupply` یک BigInt است.

// Solidity: function balanceOf(address account) public view returns (uint256);
const balance = await readOnlyContract.balanceOf("0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B");
// مقدار `balance` نیز یک BigInt خواهد بود.
~~~~

---

# فراخوانی ایستا روی توابع نوشتنی

قابلیتی قدرتمند و اغلب نادیده‌گرفته‌شده، توانایی **شبیه‌سازی یک تراکنش تغییردهنده‌ی وضعیت** بدون ارسال واقعی آن یا نیاز به امضا است. این کار با استفاده از متد `.staticCall()` روی تابع انجام می‌شود.

---

## عملکرد `.staticCall()`

- نود تراکنش را در یک محیط **شبیه‌سازی‌شده** اجرا می‌کند.
- نتیجه‌ی تراکنش را برمی‌گرداند یا اگر تراکنش برگشت بخورد، یک **خطا** پرتاب می‌کند.
- این شبیه‌سازی وضعیت بلاک‌چین را تغییر نمی‌دهد و **گس مصرف نمی‌کند**.

---

## مزایای استفاده از `.staticCall()`

- پیش‌بینی بسیار دقیق‌تری از نتیجه‌ی تراکنش نسبت به بررسی‌های ساده سمت کلاینت فراهم می‌کند.
- تمام شروط `require` و منطق داخلی قرارداد را در نظر می‌گیرد.
- می‌تواند تجربه کاربری را بهبود دهد با فراهم کردن بازخورد دقیق و فوری از موفق یا ناموفق بودن یک تراکنش.

~~~~javascript
// Solidity: function transfer(address to, uint256 amount) public returns (bool);
try {
    // شبیه‌سازی فراخوانی transfer
    await writeableContract.transfer.staticCall(recipientAddress, amount);
    console.log("اعتبارسنجی موفق: احتمالاً انتقال موفق خواهد بود.");
} catch (error) {
    console.error("اعتبارسنجی ناموفق: احتمالاً انتقال شکست می‌خورد.", error);
}
~~~~

---

# اجرای توابع تغییردهنده‌ی وضعیت (تراکنش‌ها)

برای اجرای تابعی که وضعیت بلاک‌چین را تغییر می‌دهد، نمونه‌ی قرارداد باید **به یک Signer متصل باشد**. این فرایند ناهمگام بوده و شامل دو مرحله مجزاست که Ethers.js با دو شی مختلف آن را مدل می‌کند.

---

## 1. فراخوانی متد و دریافت TransactionResponse

- فراخوانی متد روی نمونه‌ی متصل‌شده به Signer، تراکنش را به شبکه ارسال می‌کند.
- این فراخوانی یک **Promise** برمی‌گرداند که تقریباً بلافاصله با یک شیء **TransactionResponse** حل می‌شود.
- این پاسخ تأیید می‌کند که تراکنش با موفقیت به mempool ارسال شده است.
- شامل جزئیاتی مثل هش تراکنش (`tx.hash`) است.
- در این مرحله، تغییر وضعیت هنوز **در زنجیره تأیید نشده** است.

---

## 2. انتظار برای ماین و دریافت TransactionReceipt

- برای انتظار ماین شدن تراکنش و وارد شدن آن به یک بلاک، از متد `.wait()` روی شیء TransactionResponse استفاده کنید.
- این متد یک **Promise** برمی‌گرداند که با یک شیء **TransactionReceipt** حل می‌شود.
- این رسید اثبات نهایی اجرای درون زنجیره‌ای است.
- شامل اطلاعات حیاتی مانند:
  - شماره بلاک
  - گس مصرف‌شده
  - وضعیت تراکنش (`1` برای موفق، `0` برای برگشت)

---

## نکات مهم

- عدم تمایز بین این دو مرحله، یکی از منابع رایج باگ و تجربه بد کاربری در dAppهاست.
- رابط کاربری باید بعد از مرحله اول یک وضعیت **"در حال انتظار"** را نمایش دهد.
- رابط کاربری فقط باید پس از تکمیل مرحله دوم به حالت **"تأیید شده"** تغییر کند.

~~~~javascript
import { ethers } from "ethers";
// فرض کنید `contractWithSigner` نمونه‌ای از قرارداد است که به Signer متصل شده.
// فرض بر این است که `recipientAddress` و `amountInWei` (از نوع BigInt) تعریف شده‌اند.

try {
    // 1. ارسال تراکنش و دریافت پاسخ اولیه
    const txResponse = await contractWithSigner.transfer(recipientAddress, amountInWei);
    console.log("تراکنش ارسال شد. هش:", txResponse.hash);
    // -- در این مرحله، رابط کاربری باید وضعیت "در حال ارسال تراکنش" را نمایش دهد. --

    // 2. انتظار برای ماین شدن تراکنش (مثلاً یک تأییدیه)
    const txReceipt = await txResponse.wait(1);
    console.log("تراکنش در بلاک تأیید شد:", txReceipt.blockNumber);

    if (txReceipt.status === 1) {
        console.log("تراکنش موفقیت‌آمیز بود!");
        // -- رابط کاربری اکنون می‌تواند وضعیت جدید را نشان دهد. --
    } else {
        console.log("تراکنش در زنجیره برگشت خورد.");
        // -- رابط کاربری باید وضعیت "تراکنش ناموفق" را نمایش دهد. --
    }

} catch (error) {
    // این بلاک معمولاً خطاهای ارسال تراکنش را مدیریت می‌کند،
    // مثل رد کردن تراکنش توسط کاربر در کیف‌پول.
    console.error("ارسال تراکنش با خطا مواجه شد:", error);
}
~~~~
---



# بازنویسی پارامترهای تراکنش

Ethers.js کنترل دقیقی بر پارامترهای تراکنش فراهم می‌کند با اجازه دادن به استفاده از یک **شیء overrides** به عنوان آرگومان نهایی در هر تابعی که وضعیت را تغییر می‌دهد. این ویژگی برای تعامل با **توابع payable** یا تنظیم دستی **پارامترهای گس** ضروری است.

---

## Overridesهای رایج

- **value**  
  مقدار اتری که با تراکنش ارسال می‌شود، به صورت **BigInt** در واحد wei مشخص می‌گردد.  
  این برای توابع **payable** استفاده می‌شود.

- **gasLimit**  
  حداکثر مقدار گسی که تراکنش مجاز به مصرف آن است.

- **maxFeePerGas / maxPriorityFeePerGas**  
  پارامترهایی برای تراکنش‌های **EIP-1559** به‌منظور کنترل هزینه گس.

---

## مثال: ارسال ETH به یک تابع payable

~~~~javascript
// Solidity: function deposit() public payable {... }

// برای ارسال 0.1 ETH ابتدا آن را به wei تبدیل می‌کنیم.
const oneTenthEthInWei = ethers.parseEther("0.1");

const tx = await contractWithSigner.deposit({ value: oneTenthEthInWei });
await tx.wait();
~~~~
---

## مثال: مشخص کردن gas limit سفارشی

~~~~javascript
// تنظیم دستی gas limit به طور کلی توصیه نمی‌شود چون تخمین خودکار Ethers معمولاً کافی است، 
// اما برای تراکنش‌های پیچیده ممکن است ضروری باشد.
const tx = await contractWithSigner.someComplexFunction(arg1, arg2, {
    gasLimit: 3_000_000n // استفاده از BigInt برای وضوح
});
await tx.wait();
~~~~
---

# استقرار قراردادها با ContractFactory

کلاس `ContractFactory` ابزاری تخصصی برای استقرار نمونه‌های جدید قرارداد روی بلاکچین است. این کلاس با استفاده از **ABI** و **bytecode** قرارداد ساخته می‌شود و باید به یک **Signer** متصل باشد تا هزینه استقرار را بپردازد.

---

## جریان استقرار

جریان استقرار مشابه جریان استاندارد تراکنش است و شامل مراحل زیر است:

1. **ساخت ContractFactory**  
   ساخت یک `ContractFactory` جدید با استفاده از ABI و bytecode قرارداد و یک Signer.

2. **فراخوانی متد `.deploy()`**  
   صدا زدن `.deploy()` روی factory و ارسال آرگومان‌های مورد نیاز سازنده (constructor).  
   - این کار تراکنش استقرار را ارسال می‌کند.  
   - یک شیء **Contract** بازمی‌گرداند که شامل اطلاعات اولیه استقرار است.

3. **فراخوانی متد `.waitForDeployment()`**  
   فراخوانی `.waitForDeployment()` روی شیء قرارداد بازگشتی.  
   - تا زمانی که تراکنش استقرار ماین شود منتظر می‌ماند.  
   - وقتی قرارداد روی شبکه فعال شود، خاتمه می‌یابد.

---

## مثال استفاده

~~~~javascript
import { ethers } from "ethers";

// فرض بر این است که `abi`، `bytecode` و `signer` قبلاً تعریف شده‌اند.

// 1. ساخت ContractFactory
const factory = new ethers.ContractFactory(abi, bytecode, signer);

// 2. استقرار قرارداد با آرگومان‌های سازنده (در صورت وجود)
const contract = await factory.deploy(arg1, arg2);

// 3. منتظر ماندن برای ماین شدن
await contract.waitForDeployment();

console.log(`قرارداد در آدرس زیر مستقر شد: ${contract.target}`);
~~~~

این فرایند تجربه‌ای یکپارچه فراهم می‌کند و بلافاصله یک شیء Contract قابل استفاده می‌دهد که دارای متدهایی مانند getAddress() و waitForDeployment() است که با به‌روزرسانی وضعیت بلاکچین به‌طور مناسب پاسخ می‌دهند.

---

# کار با رویدادهای قرارداد

برای توسعه‌دهندگان Solidity، کلیدواژه `emit` بخش اصلی طراحی قرارداد است که روشی کم‌هزینه برای ثبت داده‌ها و ارتباط با اپلیکیشن‌های خارج از زنجیره فراهم می‌کند. Ethers.js API قدرتمند و شهودی برای مصرف این رویدادها، هم به‌صورت بلادرنگ و هم از طریق پرس‌وجوی گزارش‌های تاریخی ارائه می‌دهد.

---

## گوش دادن به رویدادهای بلادرنگ

برای اشتراک در رویدادها به محض اینکه توسط قرارداد صادر شدند، روش اصلی به صورت زیر است:

~~~~javascript
contract.on(eventName, listenerCallback)
~~~~

---

# محتوای رویداد در Ethers.js v6

تابع callback پارامترهای رویداد را به‌صورت آرگومان‌های جداگانه دریافت می‌کند، به‌علاوه آرگومان نهایی که شیء **Event** غنی‌شده است.

---

## محتوای شیء Event

این شیء نهایی حاوی فراداده‌ی جامع درباره‌ی رویداد است و منبع اطلاعاتی قدرتمند و قابل اطمینانی به‌شمار می‌رود. شامل موارد زیر است:

- **event.args**  
  یک شیء شبیه آرایه که شامل پارامترهای رویداد است، قابل دسترسی با ایندکس یا نام (در صورت کامل بودن ABI).

- **event.log**  
  شیء Log خام از نود، شامل جزئیاتی مانند `blockNumber`، `transactionHash` و غیره.

- **event.eventName**  
  نام رویدادی که تریگر شده است.

- **event.removeListener()**  
  روشی برای لغو ثبت این listener خاص.

~~~~javascript
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value);

console.log("در حال گوش دادن به رویدادهای Transfer بلادرنگ...");

contract.on("Transfer", (from, to, value, event) => {
    console.log("--- رویداد جدید Transfer دریافت شد ---");
    console.log(`فرستنده: ${from}`);
    console.log(`گیرنده: ${to}`);
    console.log(`مقدار: ${ethers.formatEther(value)}`);

    // دسترسی به فراداده از شیء event نهایی
    console.log(`شماره بلاک: ${event.log.blockNumber}`);
    console.log(`هش تراکنش: ${event.log.transactionHash}`);
});
~~~~

---

# Listener عمومی

برای گوش دادن به **تمام رویدادها**ی صادرشده توسط یک قرارداد، می‌توانید از رشته‌ی wildcard به صورت `*` استفاده کنید.

- در این حالت، callback فقط یک آرگومان دریافت می‌کند: شیء **event**.
- این موضوع ضروری است چون تعداد و نوع آرگومان‌ها برای هر رویداد متفاوت است.

## مثال

~~~~javascript
contract.on("*", (event) => {
  console.log(`رویداد ${event.eventName} صادر شد با داده‌های:`, event.args);
});
~~~~

---

# قابلیت اطمینان در گوش دادن بلادرنگ به رویدادها

توجه به این نکته مهم است که قابلیت اطمینان در گوش دادن به رویدادهای بلادرنگ می‌تواند به **provider** بستگی داشته باشد.

- اگرچه اغلب به‌خوبی عمل می‌کند، برخی محیط‌ها — مخصوصاً با **providerهای تزریق‌شده در مرورگر** — ممکن است **تاخیر یا افت رویداد** داشته باشند.
- برای اپلیکیشن‌های تولیدی که نیاز به **جریان رویداد بسیار قابل‌اعتماد** دارند، توصیه می‌شود از اتصال اختصاصی **WebSocket** به یک نود استفاده شود.

---

# پرس‌وجوی گزارش‌های رویداد تاریخی

برای بازیابی گزارش‌های مربوط به رویدادهایی که قبلاً رخ داده‌اند، متد `contract.queryFilter()` در Ethers.js v6 استانداردترین و قدرتمندترین راه‌حل است. این متد امکان جستجوی مؤثر در بازه‌ای از بلاک‌ها برای رویدادهای خاص را فراهم می‌کند.

## متد اصلی

~~~~javascript
contract.queryFilter(eventFilter, fromBlock, toBlock)
~~~~

---

# آرگومان‌های `contract.queryFilter()`

متد `contract.queryFilter()` در Ethers.js v6 آرگومان‌های زیر را می‌پذیرد:

## 1. `eventFilter`

- یک **شیء فیلتر** که مشخص می‌کند:
  - کدام **رویداد** باید جستجو شود.
  - کدام پارامترهای **indexed** برای فیلتر استفاده شود.
- این فیلتر معمولاً با استفاده از شیء `contract.filters` ساخته می‌شود.

**مثال:**

~~~~javascript
const filter = contract.filters.Transfer(senderAddress, null);
~~~~

## 2. fromBlock (اختیاری)  
شماره بلاک ابتدایی برای جستجو. می‌تواند:

- یک شماره بلاک خاص باشد (مثلاً 12345678)

- یک برچسب مانند 'earliest'

- پیش‌فرض: 0 (بلاک پیدایش)

## 3. toBlock (اختیاری)  
شماره بلاک انتهایی برای جستجو. می‌تواند:

- یک شماره بلاک خاص

- یک برچسب مانند 'latest'

- پیش‌فرض: 'latest' (آخرین بلاک)

----

~~~~javascript
// مثال: دریافت تمام رویدادهای `Transfer` از 1000 بلاک گذشته
const currentBlock = await provider.getBlockNumber();
const fromBlock = currentBlock - 1000;

// ساخت فیلتر برای رویداد "Transfer"
const transferFilter = contract.filters.Transfer;

// پرس‌وجوی بلاکچین برای رویدادهای گذشته
const pastEvents = await contract.queryFilter(transferFilter, fromBlock, 'latest');

console.log(`تعداد ${pastEvents.length} رویداد Transfer در 1000 بلاک گذشته یافت شد.`);

pastEvents.forEach(event => {
    // شیء event بازگشتی از queryFilter مشابه on() است
    console.log(
        `بلاک ${event.blockNumber}: از ${event.args.from} به ${event.args.to} به مبلغ ${event.args.value.toString()}`
    );
});
~~~~

---

# انتخاب روش مناسب برای جستجوی رویدادها

اگرچه Ethers.js همچنین متد سطح پایین‌تر `provider.getLogs()` را فراهم می‌کند، **اکیداً توصیه می‌شود** برای اکثر موارد از `contract.queryFilter()` استفاده شود.

## چرا استفاده از `contract.queryFilter()` بهتر است؟

- `contract.queryFilter()` به‌طور خودکار جستجو را به آدرس قرارداد محدود می‌کند و باعث می‌شود:
  - **امن‌تر** باشد: از تطبیق ناخواسته با قراردادهای نامرتبط جلوگیری می‌کند.
  - **مفهومی‌تر** باشد: از ABI و تعریف رویدادها به‌صورت مستقیم استفاده می‌کند.

## محدودیت‌های `provider.getLogs()`

- در سطح **نود** عمل می‌کند و به قرارداد خاصی وابسته نیست.
- اگر آدرس قرارداد به‌طور خاص مشخص نشود، ممکن است **گزارش‌هایی از تمام قراردادهای شبکه** که موضوع (topic) مشابه دارند بازگرداند.
- این می‌تواند منجر به:
  - **دریافت بیش از حد داده**
  - **کاهش عملکرد**
  - **بروز باگ‌های ظریف** در هنگام فیلتر دستی لاگ‌ها شود

## بهترین روش

همیشه از `contract.queryFilter()` استفاده کنید مگر اینکه نیاز خاص و پیشرفته‌ای برای دسترسی خام به گزارش‌ها با `provider.getLogs()` داشته باشید.

---

# ساخت و استفاده از فیلترهای رویداد

کارایی جستجوی گزارش‌ها به استفاده از کلیدواژه `indexed` در اعلان‌های رویداد Solidity وابسته است.

## پارامترهای Indexed در برابر Non-Indexed

- فقط **پارامترهای indexed** را می‌توان برای **فیلتر در سطح نود** استفاده کرد.
- این تفاوت دارای تأثیرات مهمی بر **عملکرد** است.

### پارامترهای Indexed:
- در آرایه **topics** لاگ درج می‌شوند.
- می‌توانند **مستقیماً برای فیلتر در نود** استفاده شوند.

### پارامترهای Non-Indexed:
- در **payload داده لاگ** ذخیره می‌شوند.
- باید پس از واکشی لاگ‌ها، **در سمت کلاینت فیلتر شوند** که ممکن است شامل داده‌های زیاد باشد.

---

## استفاده از `contract.filters` در Ethers.js

Ethers.js شیء `contract.filters` را به عنوان راهی ساده برای ساخت فیلترهای موضوعی جهت استفاده با `queryFilter()` فراهم می‌کند.

- این فیلترها مطابق ساختار و منطق پارامترهای `indexed` در رویدادهای Solidity هستند.
- آن‌ها **فیلترهای topic** مناسب را برای جستجوی مؤثر لاگ‌ها تولید می‌کنند.

---

## مثال ساخت فیلتر

فرض بر این است که رویداد Solidity به این صورت تعریف شده است:

~~~~solidity
contract.filters.EventName(arg1, arg2,...)
~~~~


# منطق فیلترسازی

هنگام ایجاد فیلتر رویداد در Ethers.js با استفاده از `contract.filters`، می‌توانید بسته به نحوه‌ی ارسال مقادیر برای آرگومان‌های **indexed**، استراتژی‌های مختلفی را برای فیلتر اعمال کنید.

## ۱. تطابق دقیق

- برای فیلتر کردن یک **تطابق دقیق** در یک آرگومان ایندکس شده، مقدار را مستقیماً وارد کنید.

~~~javascript
contract.filters.Transfer("0xSenderAddress", null);
~~~

این فیلتر تنها رویدادهایی را تطبیق می‌دهد که آدرس فرستنده دقیقاً برابر با "0xSenderAddress" باشد.

---

## ۲. تطابق با علامت عام (Wildcard)

برای پذیرفتن هر مقداری به عنوان ورودی برای آرگومان ایندکس شده (یعنی استفاده از wildcard)، مقدار `null` را ارسال کنید.

~~~javascript
contract.filters.Transfer(null, "0xRecipientAddress");
~~~

این فیلتر تمام رویدادهایی که آدرس گیرنده‌شان "0xRecipientAddress" باشد را تطبیق می‌دهد، فارغ از اینکه فرستنده چه کسی است.

### ۳. چندین مقدار (شرط OR)

برای فیلتر کردن چند مقدار (شرط OR منطقی)، یک آرایه از آن مقادیر را ارسال کنید.

~~~javascript
contract.filters.Transfer(["0xAddr1", "0xAddr2"], null);
~~~

این فیلتر رویدادهایی را تطبیق می‌دهد که آدرس فرستنده "0xAddr1" یا "0xAddr2" باشد.

---

~~~javascript
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value);
const myAddress = "0x...";
const aliceAddress = "0x...";
const bobAddress = "0x...";

// 1. فیلتر برای تمام انتقال‌هایی که *از* myAddress انجام شده‌اند.
const sentFilter = contract.filters.Transfer(myAddress, null);
const sentEvents = await contract.queryFilter(sentFilter, -10000); // آخرین ۱۰٬۰۰۰ بلاک

// 2. فیلتر برای تمام انتقال‌هایی که *به* myAddress انجام شده‌اند.
const receivedFilter = contract.filters.Transfer(null, myAddress);
const receivedEvents = await contract.queryFilter(receivedFilter, -10000);

// 3. فیلتر برای انتقال‌هایی که از Alice یا Bob آمده‌اند.
const fromAliceOrBobFilter = contract.filters.Transfer([aliceAddress, bobAddress]);
const complexEvents = await contract.queryFilter(fromAliceOrBobFilter, -10000);
~~~

---

# تجزیه آرگومان‌ها و لاگ‌های رویداد

یک **تغییر شکسته‌شده** (breaking change) مهم در **Ethers.js نسخه ۶** رخ داده است که نحوه‌ی دسترسی به رویدادها از receipt تراکنش را تغییر داده است.

## تغییر از نسخه v5 به v6

- **Ethers.js v5**:  
  شیء `TransactionReceipt` شامل آرایه‌ای به نام `receipt.events` بود که شامل رویدادهای **از پیش تجزیه‌شده** بود.

- **Ethers.js v6**:  
  این آرایه **حذف شده** است. اکنون شیء `TransactionReceipt` فقط شامل آرایه‌ی **خام `logs`** است.

## نحوه تجزیه لاگ‌ها در نسخه ۶

برای دریافت داده‌های ساختاریافته از رویدادها در Ethers.js v6:

1. به آرایه‌ی `logs` از `TransactionReceipt` دسترسی پیدا کنید.
2. در هر لاگ یک به یک پیمایش کنید.
3. از `interface` قرارداد برای **تجزیه دستی** هر لاگ استفاده کنید.

---

## مثال

~~~javascript
const receipt = await tx.wait();
for (const log of receipt.logs) {
  try {
    const parsed = contract.interface.parseLog(log);
    console.log(`رویداد: ${parsed.name}`, parsed.args);
  } catch (err) {
    // اگر این لاگ مربوط به قرارداد دیگری باشد، خطا پرتاب می‌شود
    continue;
  }
}
~~~

## چرا این روش؟
این روش طولانی‌تر است، اما همچنین:

- **صریح** است: کنترل کامل روی نحوه تجزیه لاگ‌ها دارید.
- **مقاوم** است: می‌توانید با خیال راحت لاگ‌های نامربوط را نادیده بگیرید.
- **دقیق** است: از مثبت‌های کاذب در رویدادهای قراردادهای دیگر جلوگیری می‌کند (مثل انتقال توکن ERC-20 در حین اجرای تابع قرارداد شما).

---

# ابزارهای ضروری در Ethers.js v6

Ethers.js مجموعه‌ای غنی از توابع کمکی دارد که برای ساخت dAppها حیاتی هستند. این ابزارها شامل تبدیل عددی، قالب‌بندی داده و هش‌های رمزنگاری هستند.

در **نسخه ۶**، این ابزارها به API‌ای **ساده‌تر و مستقیم‌تر** تغییر یافته‌اند.

---

## تغییر ساختار API در نسخه ۶

- فضای نام `ethers.utils` **حذف شده** است.
- اکنون توابع کمکی مستقیماً از شیء اصلی `ethers` در دسترس هستند.

این تغییر تجربه‌ی توسعه‌دهنده را ساده‌تر کرده و خوانایی کد را بهبود می‌بخشد.

---

# عملیات عددی با BigInt

یکی از تغییرات اساسی در نسخه ۶، جایگزینی کامل کلاس `BigNumber` با نوع **بومی `BigInt`** جاوااسکریپت است.

---

## چرا BigInt؟

- عددهای جاوااسکریپت از نوع **شناور** هستند.
- فقط تا عدد `Number.MAX_SAFE_INTEGER` ایمن‌اند (۲⁵³ − ۱).
- این محدودیت به‌راحتی توسط مقادیر `uint256` در Solidity شکسته می‌شود.
- `BigInt` از اعداد با دقت بی‌نهایت پشتیبانی می‌کند و برای توسعه‌ی Ethereum ایده‌آل است.

---

## مزایای BigInt

- استفاده از **عملگرهای ریاضی طبیعی**:
  - به‌جای `.add()`، `.sub()` و غیره، از `+`، `-`، `*`، `/` استفاده می‌کنید.
- کد عددی را **ساده‌تر و قابل فهم‌تر** می‌کند.
- **کاهش باگ‌ها** به‌خاطر حذف زنجیره‌ی توابع پیچیده.

---

## نکته مهم

BigInt را **نمی‌توان با عددهای معمولی جاوااسکریپت** در یک عملیات ریاضی ترکیب کرد.

### مثال:

~~~javascript
const a = 1000n;           // BigInt
const b = 42;              // Number

const result = a + b;      // ❌ TypeError: نمی‌توان BigInt را با انواع دیگر ترکیب کرد
~~~

برای عملیات ریاضی، باید سازگاری نوع را حفظ کنید.

---

### خلاصه
از BigInt برای تمام اعداد Solidity (مثل uint256، int128 و غیره) استفاده کنید.

از توابع کمکی از شیء اصلی ethers استفاده کنید.

از ترکیب BigInt و Number خودداری کنید.

## ایجاد BigInt
~~~javascript
*   از رشته: `const val = BigInt("1000000000000000000");`
*   با پسوند `n`: `const val = 1000000000000000000n;`
~~~

## عملیات با BigInt
~~~javascript
const price = 1500n;
const quantity = 3n;

const totalCost = price * quantity; // 4500n
const newPrice = price + 50n;      // 1550n
const isEqual = (price === 1500n);  // true

// این خط خطا خواهد داد
// const invalidSum = price + 100;

// روش صحیح
const validSum = price + BigInt(100); // 1600n
~~~

---

# تبدیل واحد اتر و توکن (parseUnits, formatUnits)

در توسعه‌ی Ethereum، مقادیر باید به صورت **کوچک‌ترین واحد غیرقابل تقسیم** (مانند wei برای Ether) نشان داده شوند. اما در UI، معمولاً **رشته‌های اعشاری خوانا برای انسان** نمایش داده می‌شوند.

Ethers.js توابع کمکی ضروری برای پل زدن بین این دو فرمت را فراهم می‌کند.

---

## parseUnits

~~~javascript
ethers.parseUnits(valueString, decimals)
~~~

رشته‌ای خوانا را (مثلاً "1.5") به کوچک‌ترین واحد به‌صورت BigInt تبدیل می‌کند.

موقع آماده‌سازی مقدار برای تراکنش روی بلاک‌چین مفید است.

در توکن‌های ERC-20 با اعشار متفاوت بسیار استفاده می‌شود.

### مثال:
~~~javascript
ethers.parseUnits("1.5", 6); // 1500000n
~~~

## parseEther

~~~javascript
ethers.parseEther(valueString)
~~~

میان‌بر برای `ethers.parseUnits(valueString, 18)`.

برای تبدیل Ether به wei استفاده می‌شود.

### مثال:
~~~javascript
ethers.parseEther("1.0"); // 1000000000000000000n
~~~

## formatUnits

~~~javascript
ethers.formatUnits(valueBigInt, decimals)
~~~

BigInt در واحد پایه (مثل wei) را به رشته‌ای اعشاری خوانا تبدیل می‌کند.

برای نمایش موجودی توکن یا مقدار تراکنش در UI کاربرد دارد.

### مثال:
~~~javascript
ethers.formatUnits(1500000n, 6); // "1.5"
~~~

## formatEther

~~~javascript
ethers.formatEther(valueBigInt)
~~~

میان‌بر برای `ethers.formatUnits(valueBigInt, 18)`.

برای تبدیل wei به Ether استفاده می‌شود.

### مثال:
~~~javascript
ethers.formatEther(1000000000000000000n); // "1.0"
~~~

---

## خلاصه
برای تبدیل ورودی کاربر به BigInt برای تراکنش‌ها از `parseUnits` و `parseEther` استفاده کنید.

برای نمایش مقادیر BigInt در UI از `formatUnits` و `formatEther` استفاده کنید.

این ابزارها دقت و ایمنی تبدیل‌ها را در تمام عملیات‌های توکن و Ether تضمین می‌کنند.

---

~~~javascript
import { ethers } from "ethers";

// --- تجزیه: تبدیل از رشته‌ی کاربر به BigInt ---

// تبدیل 1.5 ETH به معادل wei (۱۸ اعشار)
const ethInWei = ethers.parseEther("1.5"); // 1500000000000000000n

// تبدیل 250 USDC به واحد پایه (با ۶ اعشار)
const usdcInBaseUnits = ethers.parseUnits("250", 6); // 250000000n

// تبدیل 50 Gwei به wei (Gwei دارای ۹ اعشار است)
const gweiInWei = ethers.parseUnits("50", "gwei"); // 50000000000n

// --- قالب‌بندی: تبدیل از BigInt به رشته‌ی خوانا ---

const balanceInWei = 3250000000000000000n;

// قالب‌بندی wei به رشته‌ی ETH
const balanceInEth = ethers.formatEther(balanceInWei); // "3.25"

// قالب‌بندی توکن با ۶ اعشار
const usdcBalance = 500123456n;
const usdcBalanceString = ethers.formatUnits(usdcBalance, 6); // "500.123456"
~~~

---

# اسامی واحدهای رایج و تعداد اعشار

در Ethereum، مقادیر Ether و توکن‌ها برحسب کوچک‌ترین واحد نشان داده می‌شوند (مثل wei). جدول زیر واحدهای متداول و تعداد اعشار مربوط به هر کدام را نشان می‌دهد.

---

## جدول ۱: اسامی واحد و اعشار

| نام واحد | اعشار |
|----------|--------|
| wei      | 0      |
| kwei     | 3      |
| mwei     | 6      |
| gwei     | 9      |
| szabo    | 12     |
| finney   | 15     |
| ether    | 18     |

---

### نکات

- **wei** کوچک‌ترین واحد ممکن در Ethereum است.
- **gwei** معمولاً برای قیمت گس استفاده می‌شود.
- **ether** واحد استاندارد در UI اکثر اپلیکیشن‌هاست.

---

# هش رمزنگاری برای تأیید در زنجیره (solidityPackedKeccak256)

یکی از نیازهای رایج در dAppها، تکرار محاسبه‌ی هش است که یک قرارداد هوشمند در زنجیره انجام می‌دهد. این کار معمولاً برای موارد زیر مورد نیاز است:

- تأیید امضای کاربر (مثل EIP-712)
- بررسی Merkle proofها
- سایر وظایف تأیید داده در زنجیره

---



## `ethers.solidityPackedKeccak256`

این تابع برای **شبیه‌سازی دقیق** عملکرد تابع `keccak256(abi.encodePacked(...))` در سالیدیتی طراحی شده است.

---

### امضای تابع (نسخه ۶)

~~~~javascript
ethers.solidityPackedKeccak256(types, values)
~~~~

## آرگومان‌ها
### types: آرایه‌ای از رشته‌ها که نشان‌دهنده نوع‌های سالیدیتی هستند، مانند "address"، "uint256"، "bytes32" و غیره.

### values: آرایه‌ای از مقادیر جاوااسکریپت که با آرایه types هم‌تراز هستند.

نکات مهم:
برای دستیابی به هش دقیق بین جاوااسکریپت و سالیدیتی، باید به جزئیات دقیق توجه شود:

### تطابق نوع‌ها: اطمینان حاصل کنید که مقادیر جاوااسکریپت دقیقاً با نوع‌های سالیدیتی مطابقت دارند. برای مثال:

- از `bigint` برای `uint256` استفاده کنید
- از آدرس‌های checksum شده برای `address` استفاده کنید

### کدگذاری (Encoding): رشته‌ها و بایت‌ها باید دقیقاً به روشی که سالیدیتی انتظار دارد کدگذاری شوند.

ناهماهنگی‌ها منجر به:
- دریافت مقدار هش متفاوت
- شکست در اعتبارسنجی یا بررسی امضای درون‌زنجیره‌ای

### مثال
~~~~javascript
const hash = ethers.solidityPackedKeccak256(
  ["address", "uint256"],
  [userAddress, 1234n]
);
~~~~

این هش برابر است با خروجی تابع زیر در سالیدیتی:

~~~~solidity
keccak256(abi.encodePacked(userAddress, uint256(1234)));
~~~~

با استفاده صحیح از `ethers.solidityPackedKeccak256`، توسعه‌دهندگان می‌توانند اطمینان حاصل کنند که داده‌ها به‌صورت صحیح در داخل و خارج از زنجیره تطبیق دارند.

---

~~~~javascript
// کد سالیدیتی برای بررسی امضا درون زنجیره:
//
// function verify(bytes32 _hash, bytes calldata _signature) public pure returns (address) {
//     return ECDSA.recover(_hash, _signature);
// }
//
// bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, a_uint256_nonce));

// کد Ethers.js برای تولید همان هش جهت امضا خارج از زنجیره:
import { ethers } from "ethers";

const signerAddress = "0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B";
const nonce = 12345n; // از bigint برای uint256 استفاده شود

const messageHash = ethers.solidityPackedKeccak256(
    ["address", "uint256"],
    [signerAddress, nonce]
);
// حالا messageHash قابل امضا توسط کیف پول کاربر است.
// const signature = await signer.signMessage(ethers.getBytes(messageHash));
~~~~

# دستکاری داده‌ها و رشته‌های هگزادسیمال

برای عملیات رمزنگاری پیچیده‌تر مانند ساختن داده برای درخت مرکل یا طرح‌های سفارشی امضا، Ethers.js مجموعه‌ای از توابع سطح پایین برای دستکاری داده ارائه می‌دهد. در نسخه ۶ بسیاری از این توابع برای وضوح بیشتر نام‌گذاری مجدد شدند.

## ethers.getBytes(hexString)

- **توضیح**: یک رشته هگزادسیمال (مثلاً `"0x1234"`) را به `Uint8Array` تبدیل می‌کند.
- **جایگزین**: جایگزین تابع `arrayify` از نسخه ۵ است.

~~~~javascript
import { getBytes } from "ethers";

// مثال
const byteArray = getBytes("0x1234");
console.log(byteArray); // Uint8Array(2) [18, 52]
~~~~

## ethers.hexlify(bytes)

- **توضیح**: یک `Uint8Array` یا آرایه‌ای از اعداد را به رشته هگزادسیمال تبدیل می‌کند.

~~~~javascript
import { hexlify } from "ethers";

// مثال
const hexString = hexlify([18, 52]);
console.log(hexString); // "0x1234"
~~~~

## ethers.concat(arrayOfBytesLike)

- **توضیح**: مجموعه‌ای از داده‌های بایتی (رشته‌های hex یا `Uint8Array`) را به هم می‌چسباند و یک رشته هگز جدید تولید می‌کند.

~~~~javascript
import { concat, getBytes } from "ethers";

// مثال
const combined = concat([
  getBytes("0x1234"),
  getBytes("0xabcd")
]);
console.log(combined); // Uint8Array(4) [18, 52, 171, 205]
~~~~

## ethers.zeroPadValue(hexString, length)

- **توضیح**: یک رشته hex را از چپ با صفر پر می‌کند تا به طول مشخصی برسد.

- **کاربرد**: برای قالب‌بندی مقادیری مانند `uint128` در یک اسلات `bytes32` مفید است.

~~~~javascript
import { zeroPadValue } from "ethers";

// مثال
const padded = zeroPadValue("0x1234", 32); // 32 بایت = 64 حرف hex
console.log(padded); // "0x0000000000000000000000000000000000000000000000000000000000001234"
~~~~

این توابع ابزارهای اساسی برای کدگذاری صحیح داده‌ها پیش از هش یا ارسال آن‌ها به قرارداد هوشمندی هستند که انتظار `bytes` یا `bytes32` دارد.

---

# به‌روزرسانی‌های کلیدی و قابلیت‌های اخیر (نسخه ۶ به بالا)

انتشار نسخه ۶ Ethers.js نقطه عطفی مهم در مسیر این کتابخانه بود؛ با تمرکز بر ویژگی‌های مدرن جاوااسکریپت، وضوح API و قابلیت اطمینان بیشتر. این پروژه به‌طور فعال نگهداری می‌شود و پشتیبانی سریع از EIPهای جدید را اضافه می‌کند تا برای آینده آماده باشد.

## انتقال از BigNumber به BigInt

مهم‌ترین تغییر ناسازگار در نسخه ۶، جایگزینی کلاس `BigNumber` سفارشی با نوع بومی `BigInt` جاوااسکریپت است.

این تغییر باعث بهره‌گیری از ویژگی‌های استاندارد جاوااسکریپت مدرن (ES2020) شده و عملکرد و خوانایی کد را افزایش می‌دهد.

همه عملیات ریاضی که قبلاً با متدهایی مانند `.add()` انجام می‌شد، اکنون باید با عملگرهای استاندارد مانند `+` نوشته شود.

~~~~javascript
// نسخه ۵
const n1 = ethers.BigNumber.from("100");
const n2 = ethers.BigNumber.from("50");
const sum = n1.add(n2);

// نسخه ۶
const n1 = BigInt("100");
const n2 = BigInt("50");
const sum = n1 + n2;
~~~~

## بازطراحی ساختار Provider و توابع کاربردی

در نسخه ۶، ساختار API Ethers.js ساده‌تر و قابل کشف‌تر شده است. فضای نام `ethers.utils` حذف شده و همه توابع به‌طور مستقیم در شیء اصلی `ethers` در دسترس هستند.

همچنین کلاس‌های Provider اکنون به‌طور مستقیم از `ethers` یا مسیر `ethers/providers` قابل ایمپورت هستند.

این تغییر نیازمند بروزرسانی ایمپورت‌ها و توابع هنگام مهاجرت از نسخه ۵ است ولی منجر به کدی تمیزتر می‌شود.

## راهنمای سریع مهاجرت: نسخه ۵ به ۶

| ویژگی / کار         | سینتکس نسخه ۵                                 | سینتکس نسخه ۶                               |
|---------------------|-----------------------------------------------|---------------------------------------------|
| اعداد بزرگ          | `ethers.BigNumber.from("100")`               | `BigInt("100")`                             |
| عملیات ریاضی        | `n1.add(n2)`                                  | `n1 + n2`                                   |
| تبدیل واحد          | `ethers.utils.parseEther("1.0")`              | `ethers.parseEther("1.0")`                  |
| قالب‌بندی واحد      | `ethers.utils.formatEther(wei)`               | `ethers.formatEther(wei)`                   |
| هش سالیدیتی         | `ethers.utils.solidityKeccak256(t, v)`        | `ethers.solidityKeccak256(t, v)`            |
| تبدیل Hex            | `ethers.utils.arrayify(hex)`                 | `ethers.getBytes(hex)`                      |
| Web3Provider         | `new ethers.providers.Web3Provider(...)`      | `new Web3Provider(...)`                     |
| RPC Provider         | `new ethers.providers.JsonRpcProvider(...)`   | `new JsonRpcProvider(...)`                  |
| ثابت‌ها              | `ethers.constants.AddressZero`                | `ethers.ZeroAddress`                        |

## پشتیبانی از EIPهای جدید

یکی از نشانه‌های سلامت و آینده‌داری یک کتابخانه بلاک‌چین، هم‌راستایی آن با تکامل پروتکل است.

Ethers.js نشان داده که به‌طور مداوم پشتیبانی از EIPهای جدید را سریع پس از نهایی شدن آن‌ها اضافه می‌کند.

### EIP-4844 (تراکنش‌های Blob)

پشتیبانی از ارسال تراکنش‌های blob برای اپ‌هایی که با رول‌آپ‌ها و لایه دوم تعامل دارند.

### EIP-7702 (کدگذاری برای EOA)

پشتیبانی از قابلیت‌های جدید برای حساب‌های EOA از نسخه 6.14.0 اضافه شده است.

### EIP-6963 (تشخیص چند کیف‌پول در مرورگر)

در نسخه 6.14.0 اضافه شد. حالا `BrowserProvider` می‌تواند همه کیف‌پول‌های نصب‌شده را شناسایی و ارائه کند.

این یکپارچگی سریع نشان می‌دهد که توسعه‌دهندگان می‌توانند روی Ethers.js حساب کنند که همیشه به‌روز و قابل اتکا باقی بماند.

## خلاصه نکات مهم از تغییرات نسخه‌های اخیر (6.12 تا 6.14)

### پایداری و استحکام

رفع مشکلات سطح پایین مانند:
- سریال‌سازی تراکنش‌ها
- کدگذاری JSON-RPC
- overflow در call stack
- خطاهای بدون کنترل

این اصلاحات باعث ایجاد کتابخانه‌ای پایدار و قابل اتکا برای استفاده در تولید می‌شوند.

### بهینه‌سازی عملکرد

بهبودهایی مانند حذف درخواست‌های تکراری برای رسید تراکنش‌ها، کارایی کلی را افزایش می‌دهند.

### یکپارچگی با اکوسیستم

- به‌روزرسانی `EtherscanProvider` برای استفاده از API جدید v2
- معرفی `BlockscoutProvider` برای پشتیبانی از مرورگر بلاک‌های دیگر

---

این روند پیشرفت مداوم و تدریجی نشان‌دهنده پروژه‌ای است که برای ساخت و نگهداری اپلیکیشن‌های حرفه‌ای روی بلاک‌چین‌های سازگار با EVM بسیار مناسب است.



</div>
