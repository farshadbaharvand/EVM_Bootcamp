<div dir="rtl">



# استفاده از اوراکل‌ها در بلاک‌چین‌های مبتنی بر EVM

## مقدمه

قراردادهای هوشمند مستقر شده در بلاک‌چین‌های سازگار با EVM ذاتاً تعیین‌پذیر و ایزوله هستند. این بدان معناست که آن‌ها به‌طور ذاتی نمی‌توانند به داده‌ها، سیستم‌ها یا APIهای خارجی (خارج از زنجیره) دسترسی داشته باشند یا با آن‌ها تعامل برقرار کنند. اوراکل‌ها این محدودیت را با ایجاد پل‌های امن بین دنیای خارج از زنجیره و داخل زنجیره حل می‌کنند.

## هدف

هدف اصلی اوراکل‌ها، فراهم کردن امکان دسترسی قراردادهای هوشمند به داده‌های خارجی یا اجرای فرآیندهای خارجی است؛ در حالی که غیرمتمرکز بودن، بی‌نیازی از اعتماد و امنیت حفظ می‌شود.

اوراکل‌ها می‌توانند:

- داده‌های دنیای واقعی را فراهم کنند (مثلاً قیمت دارایی‌ها، وضعیت آب‌وهوا، نتایج مسابقات ورزشی)
- رویدادهای خارجی یا تماس با APIها را فعال کنند
- نتایج محاسبات خارج از زنجیره را به داخل زنجیره بیاورند
- پیام‌های بین زنجیره‌ای را به‌صورت امن منتقل کنند

## انواع اوراکل‌ها

### 1. اوراکل‌های نرم‌افزاری

- با منابع داده آنلاین مانند APIها، وب‌سایت‌ها و پایگاه‌های داده تعامل دارند.
- مورد استفاده رایج: وارد کردن قیمت دارایی‌ها یا داده‌های آب‌وهوا به قراردادهای هوشمند.

### 2. اوراکل‌های سخت‌افزاری

- دستگاه‌های فیزیکی (سنسورهای IoT، اسکنرهای بارکد) را به قراردادهای هوشمند متصل می‌کنند.
- در برنامه‌های زنجیره تأمین رایج هستند.

### 3. اوراکل‌های ورودی (Inbound)

- داده‌ها را از دنیای بیرون به بلاک‌چین می‌آورند.

### 4. اوراکل‌های خروجی (Outbound)

- امکان ارسال اطلاعات یا فرمان از قرارداد هوشمند به سیستم‌های خارجی را فراهم می‌کنند.

### 5. اوراکل‌های بین‌زنجیره‌ای

- داده‌ها را بین بلاک‌چین‌های مختلف منتقل می‌کنند.

### 6. اوراکل‌های انسانی

- متخصصان موضوعی داده‌ها را به‌صورت دستی وارد بلاک‌چین می‌کنند.

---

# مدل‌های معماری اوراکل

این بخش، مدل‌های اصلی ارائه داده توسط اوراکل‌ها به بلاک‌چین را بررسی می‌کند و تمرکز آن بر ملاحظات فنی و اقتصادی است که بر انتخاب توسعه‌دهندگان تأثیر می‌گذارند.

## ضرورت غیرمتمرکزسازی

بلاک‌چین‌ها به‌گونه‌ای طراحی شده‌اند که سیستم‌هایی مستقل و تعیین‌پذیر باشند. این ایزوله بودن یک ویژگی است، نه یک نقص، زیرا اطمینان می‌دهد که هر نود در شبکه می‌تواند با پردازش تراکنش‌ها و داده‌های یکسان به اجماع برسد.

اما همین ویژگی باعث می‌شود قراردادهای هوشمند نتوانند به داده‌های خارجی دسترسی مستقیم داشته باشند. افزودن یک منبع داده خارجی از طریق یک اوراکل متمرکز (یک نهاد منفرد) یک نقطه شکست مرکزی را دوباره معرفی می‌کند.

این کار ارزش برنامه غیرمتمرکز را زیر سوال می‌برد، چرا که امنیت و قابلیت اعتماد کل سیستم وابسته به همان جزء متمرکز می‌شود.

برای حل این مشکل، استاندارد صنعتی استفاده از **شبکه‌های اوراکل غیرمتمرکز (DONs)** است.

یک DON از چندین نود مستقل، توزیع‌شده جغرافیایی و مقاوم در برابر Sybil تشکیل شده است.

این نودها داده‌ها را از منابع مختلف خارجی جمع‌آوری می‌کنند، بر روی مقدار صحیح به اجماع می‌رسند (معمولاً از طریق میانه‌گیری)، و سپس مقدار تجمیع‌شده را به بلاک‌چین گزارش می‌دهند.

این معماری غیرمتمرکز در برابر دستکاری مقاوم است و دسترسی بالا را تضمین می‌کند، چرا که برای خرابکاری باید تعداد زیادی از نودهای مستقل را هم‌زمان به خطر انداخت.

## مدل‌های تحویل داده: پوش (Push) در برابر پول (Pull)

اگرچه غیرمتمرکزسازی در سطح نود یک پایه مشترک است، تفاوت اصلی بین خدمات اوراکل در **روش تحویل داده به بلاک‌چین** نهفته است.

این تفاوت باعث شکل‌گیری دو مدل اصلی شده است: مدل پیش‌فعال **پوش (Push)** و مدل واکنشی **پول (Pull)**.

انتخاب بین این دو مدل تأثیر زیادی بر تازگی داده، تأخیر، هزینه گس و طراحی کلی اپلیکیشن دارد.

---

## مدل پوش (Push)

### مکانیزم

در مدل Push، شبکه اوراکل غیرمتمرکز به‌صورت خودکار مقدار داده را روی بلاک‌چین به‌روزرسانی می‌کند. این به‌روزرسانی‌ها پیوسته نیستند، بلکه توسط شرایط از پیش تعیین‌شده فعال می‌شوند:

- **آستانه انحراف**: اگر مقدار خارج‌از‌زنجیره دارایی از مقدار فعلی درون‌زنجیره‌ای بیش از حد مشخصی (مثلاً ۰.۵٪ یا ۱٪) انحراف داشته باشد، به‌روزرسانی انجام می‌شود.
- **ضربان قلب (Heartbeat)**: اگر مدت مشخصی از آخرین به‌روزرسانی گذشته باشد (مثلاً هر ساعت)، داده مجدداً ارسال می‌شود تا داده بیش از حد کهنه نشود.

### وضعیت درون‌زنجیره‌ای

فرایند فوق، داده‌ها را در قراردادی به نام **مرجع (Reference Contract)** یا **تجمیع‌کننده (Aggregator)** ذخیره می‌کند.

قراردادهای هوشمندی که به این داده‌ها نیاز دارند، می‌توانند با یک فراخوانی ساده (view call) این مقدار را بخوانند که کم‌هزینه و مستقیم است.

### مورد استفاده اصلی

مدل Push برای **دسترس‌پذیری مداوم و مطمئن داده در زنجیره** طراحی شده است.

مثال بارز آن، پروتکل‌های وام‌دهی و استقراض در DeFi مانند Aave و Compound هستند. این پلتفرم‌ها برای ارزش‌گذاری وثیقه‌ها و اجرای نقدسازی از قیمت‌های آنی و درون‌زنجیره‌ای استفاده می‌کنند.

**Chainlink Data Feeds** که از این مدل استفاده می‌کند، به استاندارد صنعتی در این حوزه تبدیل شده است.

### محدودیت‌ها

نقطه ضعف اصلی مدل Push، **هزینه‌های عملیاتی** آن است. شبکه اوراکل باید هزینه گس هر به‌روزرسانی درون‌زنجیره‌ای را بپردازد.

این هزینه‌ها برای هر ضربان قلب و هر آستانه انحراف در تمام زنجیره‌های پشتیبانی‌شده صرف می‌شود، حتی اگر هیچ اپلیکیشنی از آن داده استفاده نکند.

در نتیجه، این مدل فقط برای دارایی‌های پرتقاضا مقرون‌به‌صرفه است و نمی‌تواند دامنه گسترده‌ای از داده‌ها یا بلاک‌چین‌های کم‌کاربر را پوشش دهد.

---

## مدل پول (Pull)

### مکانیزم

در مدل Pull، داده فقط در صورتی به بلاک‌چین وارد می‌شود که توسط کاربر یا اپلیکیشن درخواست شود.

شبکه اوراکل در این مدل، **گزارش‌های رمزنگاری‌شده خارج از زنجیره** را با فرکانس بالا تولید می‌کند (مثلاً Pyth Network هر ۴۰۰ میلی‌ثانیه یک‌بار به‌روزرسانی می‌کند).

این گزارش‌ها از طریق API یا خدمات خارج از زنجیره در دسترس هستند.

### وضعیت درون‌زنجیره‌ای

برای استفاده از داده، اپلیکیشن یا کاربر باید ابتدا گزارش امضا شده را از خارج دریافت کند.

این پیام امضاشده، بخشی از تراکنشی است که به بلاک‌چین ارسال می‌شود.

تراکنش، تابعی را در dApp فراخوانی می‌کند که پیام را به قرارداد اوراکل ارسال می‌کند.

قرارداد اوراکل **امضای گزارش** را تأیید می‌کند و اگر معتبر باشد، مقدار جدید را به‌روز می‌کند.

سپس منطق اپلیکیشن می‌تواند قیمت تازه را **در همان تراکنش اتمی** بخواند و ادامه دهد.

### مورد استفاده اصلی

مدل Pull برای مواردی با نیاز به **تازگی بالا و تأخیر کم** ایده‌آل است. مثال‌ها شامل بازارهای دائمی، پروتکل‌های اختیار معامله و دیگر مشتقات هستند.

**Pyth Network** یکی از پیشگامان این مدل است.

### مزایا

این معماری **مقیاس‌پذیرتر و گس-بهینه‌تر** است؛ چرا که هزینه گس بر عهده کاربر است.

از آنجا که شبکه اوراکل نیازی به پرداخت هزینه برای داده‌هایی که استفاده نمی‌شوند ندارد، می‌تواند هزاران داده مختلف را روی زنجیره‌های مختلف پشتیبانی کند.

همچنین، به خاطر فرکانس بالای گزارش‌های خارج از زنجیره، داده‌ها **تازه‌تر و کم‌تأخیرتر** هستند.

### نکته برای توسعه‌دهندگان

توسعه‌دهندگان باید به این نکته توجه کنند که مسئولیت و هزینه به‌روزرسانی داده به‌عهده **کاربر اپلیکیشن** است.

بنابراین طراحی اپلیکیشن، هم در بخش on-chain و هم off-chain، باید به گونه‌ای باشد که گزارش امضاشده را گرفته و آن را قبل از استفاده، به قرارداد اوراکل ارائه دهد.

---


## ملاحظات اقتصادی

انتخاب بین این مدل‌ها صرفاً یک موضوع فنی نیست، بلکه به‌شکل بنیادی توسط **اقتصاد** هدایت می‌شود.

**نحوه تخصیص هزینه گاز** — اینکه هزینه توسط شبکه پرداخت شود (**مدل پوش**) یا کاربر نهایی (**مدل پول**) — مستقیماً ویژگی‌های این سرویس را تعیین می‌کند.

در مدل پوش، شبکه هزینه را متحمل می‌شود، بنابراین تنها یک **مجموعه منتخب از فیدهای بسیار قابل‌اعتماد** ارائه می‌شود که در آن‌ها تقاضای مداوم و گسترده توجیه‌کننده این هزینه عملیاتی است. این مدل کاملاً برای **موج اول دیفای (DeFi)** که تحت سلطه پروتکل‌های وام‌دهی بود، مناسب بود.

در مدل پول، هزینه به کاربری منتقل می‌شود که از به‌روزرسانی، **ارزش آنی** دریافت می‌کند. این امکان را فراهم می‌کند تا شبکه یک **کاتالوگ عظیم و بلندمدت از فیدها** با سربار کم ارائه دهد، زیرا نیازی به حفظ وضعیت درون‌زنجیره‌ای دارایی‌های بلااستفاده ندارد.

این ساختار اقتصادی امکان توسعه‌ی **نسل جدیدی از برنامه‌های دیفای حساس به تأخیر** مانند بازارهای مشتقه را فراهم می‌کند که به طیف وسیع‌تری از دارایی‌ها و به‌روزرسانی‌های مکررتری نیاز دارند — چیزی که مدل پوش از نظر اقتصادی نمی‌تواند تأمین کند.

بنابراین، تکامل از بازاری غالباً مبتنی بر پوش به بازاری با رقبای پول‌محور قوی، بازتابی از **بلوغ و تخصصی‌شدن اکوسیستم دیفای** است. انتخاب مدل اوراکل در اصل یک **تصمیم اقتصادی** درمورد محل تخصیص هزینه گاز در معماری اپلیکیشن برای رسیدن به ویژگی‌های عملکردی مطلوب است.

---

## جدول ۱: تحلیل مقایسه‌ای ارائه‌دهندگان اصلی اوراکل

| ارائه‌دهنده      | مدل(های) اصلی                      | مکانیزم دریافت داده                                                                     | ویژگی کلیدی                                                                                         | کاربرد معمول در EVM                                         |
|------------------|------------------------------------|-------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|
| **Chainlink**     | پوش (فیدهای داده)، پول (جریان‌های داده) | شبکه غیرمتمرکز از اپراتورهای مستقل که داده‌ها را از چندین منبع جمع‌آوری می‌کنند.            | پیشرو از نظر امنیت و قابلیت اطمینان؛ پذیرش گسترده در اکوسیستم.                                         | وام‌دهی و قرض‌گیری دیفای (مثل Aave)، مدیریت دارایی‌ها         |
| **Pyth Network**  | پول                               | شبکه‌ای از ناشران داده‌ی دست اول (صرافی‌ها، شرکت‌های معاملاتی، بازارسازها).             | به‌روزرسانی‌های خارج‌زنجیره‌ای با فرکانس بالا (کمتر از یک ثانیه) و داده‌های کم‌تأخیر بر اساس تقاضا.     | مشتقات حساس به تأخیر مانند قراردادهای دائمی و اختیار معامله |
| **Band Protocol** | پوش (از طریق BandChain)           | شبکه غیرمتمرکز از اعتبارسنج‌ها در بلاک‌چین اختصاصی خود (BandChain مبتنی بر Cosmos-SDK).  | سازگاری بین‌زنجیره‌ای و انعطاف‌پذیری برای ساخت اسکریپت‌های اوراکل سفارشی توسط توسعه‌دهندگان.             | اپلیکیشن‌های چندزنجیره‌ای نیازمند فیدهای داده‌ی خاص           |
| **API3**          | دست اول (از طریق Airnode)         | ارائه‌دهندگان داده گره‌های اوراکل خود را اجرا می‌کنند ("Airnode")، اتصال مستقیم API به بلاک‌چین. | حذف واسطه‌های گره اوراکل شخص ثالث، با هدف شفافیت بیشتر منابع داده و کارایی هزینه‌ای بالاتر.            | یکپارچه‌سازی مستقیم با هر API وب۲ برای انواع مختلف داده‌ها فراتر از فیدهای قیمتی |

---

# پیاده‌سازی فیدهای قیمت با مدل پوش در Chainlink

## مقدمه‌ای بر فیدهای داده‌ی Chainlink

فیدهای داده‌ی Chainlink قیمت دارایی‌ها را از طریق شبکه‌ای غیرمتمرکز، متشکل از اپراتورهای گره‌ای که از نظر امنیتی بررسی و مقاوم در برابر Sybil هستند، جمع‌آوری و ارائه می‌کنند. این فیدها توسط مشوق‌های رمزنگاری-اقتصادی ایمن‌سازی می‌شوند، به‌گونه‌ای که گره‌ها برای ارائه‌ی داده‌ی صحیح پاداش می‌گیرند و برای رفتار خرابکارانه تنبیه می‌شوند.

مولفه‌ی اصلی در قرارداد هوشمند برای توسعه‌دهندگان، **قرارداد پراکسی** است که اینترفیس `AggregatorV3Interface` را فراهم می‌کند.

این اینترفیس آدرس ثابتی را همراه با مجموعه‌ای از توابع پایدار برای دریافت داده ارائه می‌دهد، حتی اگر قراردادهای اصلی توسط تیم Chainlink ارتقا یابند.

## استفاده از داده‌ی قیمتی به‌روز

پرکاربردترین حالت، دریافت قیمت جدید یک دارایی است. این کار از طریق اجرای فراخوان `view` به تابع `latestRoundData()` روی آدرس قرارداد پراکسی مربوط به فید انجام می‌شود.

## تشریح اینترفیس

### امضای تابع `latestRoundData()`

~~~~solidity
function latestRoundData()
    external
    view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
~~~~

### مقادیر بازگشتی

تابع `latestRoundData()` پنج مقدار باز می‌گرداند:

1. **roundId**:  
   - نوع: `uint80`  
   - توضیح: شناسه‌ی یکتای ترتیبی برای دور تجمیع که این پاسخ را تولید کرده است.

2. **answer**:  
   - نوع: `int256`  
   - توضیح: مقدار قیمت تجمیع‌شده.  
   - مهم: این مقدار **عدد مقیاس‌گذاری‌شده** است. برای تفسیر مقدار واقعی، باید تعداد اعشار مورد استفاده در فید را بررسی کنید؛ این کار با فراخوانی تابع `decimals()` انجام می‌شود.

3. **startedAt**:  
   - نوع: `uint256`  
   - توضیح: زمان یونیکس شروع این دور.  
   - معمولاً برای دیباگ یا ردیابی توسعه‌یافته استفاده می‌شود.

4. **updatedAt**:  
   - نوع: `uint256`  
   - توضیح: زمان یونیکس آخرین به‌روزرسانی این پاسخ روی بلاک‌چین.  
   - این مقدار برای تأیید تازگی داده بسیار مهم است.

5. **answeredInRound**:  
   - نوع: `uint80`  
   - توضیح: شناسه‌ی دوری که پاسخ در آن محاسبه شده است.  
   - برای تأیید اینکه پاسخ از دور کامل‌شده گرفته شده استفاده می‌شود.

### نکات

- در اغلب موارد تنها `answer`، `updatedAt` و `roundId` مورد نیاز است.
- همیشه بررسی کنید که `updatedAt != 0` باشد تا مطمئن شوید دور کامل شده و داده معتبر است.
- برای فیدهای قیمتی، مقدار `answer` را با در نظر گرفتن اعشار مناسب تبدیل کنید.

---

## مثال کد: PriceConsumerV3

قرارداد زیر پیاده‌سازی حداقلی برای خواندن آخرین قیمت ETH/USD در شبکه آزمایشی Sepolia را نشان می‌دهد.

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

/**
 * @title PriceConsumerV3
 * @notice قراردادی ساده برای دریافت آخرین قیمت از فید داده‌ی Chainlink.
 */
contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * @notice سازنده، رابط فید داده را مقداردهی می‌کند.
     * @dev شبکه: Sepolia
     * @dev فید: ETH/USD
     * @dev آدرس: 0x694AA1769357215DE4FAC081bf1f309aDC325306
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x694AA1769357215DE4FAC081bf1f309aDC325306
        );
    }

    /**
     * @notice بازمی‌گرداند آخرین قیمت را از فید داده.
     * @return قیمت آخر به‌صورت عدد صحیح (دارای اعشار).
     */
    function getLatestPrice() public view returns (int256) {
        // prettier-ignore
        (
            /* uint80 roundId */,
            int256 answer,
            /* uint256 startedAt */,
            /* uint256 updatedAt */,
            /* uint80 answeredInRound */
        ) = priceFeed.latestRoundData();
        
        // فید ETH/USD روی Sepolia دارای ۸ اعشار است.
        // برای دریافت قیمت واقعی به دلار، answer را بر 10**8 تقسیم کنید.
        return answer;
    }
}
~~~~

---

## بازیابی داده‌های قیمتی تاریخی

معماری Chainlink امکان دریافت داده‌های قیمتی تاریخی از شبکه اوراکل غیرمتمرکز آن را فراهم می‌کند. هر به‌روزرسانی قیمت با یک `roundId` یکتا همراه است که امکان درخواست داده از هر دور قبلی که هنوز روی زنجیره ذخیره شده را می‌دهد.

این کار با استفاده از تابع `getRoundData(uint80 _roundId)` انجام می‌شود که در اینترفیس `AggregatorV3Interface` ارائه شده است.

## مثال کد: HistoricalPriceConsumer

این مثال، قرارداد قبلی را توسعه می‌دهد تا یک تابع برای بازیابی قیمت از یک دور مشخص اضافه کند.

~~~~solidity
//... imports و تعریف قرارداد مشابه بالا...

contract HistoricalPriceConsumer {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        priceFeed = AggregatorV3Interface(
            0x694AA1769357215DE4FAC081bf1f309aDC325306 // Sepolia ETH/USD
        );
    }

    /**
     * @notice داده‌ی قیمتی تاریخی مربوط به یک roundId مشخص را بازمی‌گرداند.
     * @param _roundId شناسه‌ی دور موردنظر برای بازیابی داده.
     * @return قیمت مربوط به دور مشخص‌شده.
     */
    function getHistoricalPrice(uint80 _roundId) public view returns (int256) {
        // prettier-ignore
        (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = priceFeed.getRoundData(_roundId);

        // مهم است که بررسی شود دور کامل شده است.
        // زمان غیرصفر نشان‌دهنده‌ی تکمیل بودن دور است.
        require(updatedAt > 0, "Round not complete");
        
        return answer;
    }
}
~~~~


## استفاده از Feed Registry

قرار دادن آدرس‌های داده‌فید به صورت هاردکد در یک قرارداد هوشمند باعث سفت و سخت شدن طراحی می‌شود. اگر آدرس یک فید به دلیل رویدادهایی مانند ارتقاء شبکه تغییر کند، قرارداد مصرف‌کننده باید دوباره مستقر شود. **Feed Registry** در Chainlink این محدودیت را با افزودن یک لایه واسط حل می‌کند.

### Feed Registry چیست؟

Feed Registry یک قرارداد هوشمند آن‌چینی است که مانند یک دفترچه آدرس عمل می‌کند و جفت دارایی‌ها (مثلاً LINK/USD) را به آدرس به‌روز داده‌فید مرتبط آن‌ها نگاشت می‌دهد.

این رجیستری توابعی مانند `latestAnswer` را در اختیار می‌گذارد که شبیه رابط aggregator هستند اما به جای فراخوانی روی یک آدرس خاص، پارامترهایی از نوع آدرس دارایی دریافت می‌کنند.

## مثال کد: مصرف‌کننده Feed Registry

این راهنما نحوه پرس‌وجوی قیمت LINK/USD را با استفاده از Feed Registry در شبکه اصلی اتریوم نشان می‌دهد. از قرارداد Denominations در Chainlink برای گرفتن آدرس استاندارد ارزهای فیاتی مانند USD استفاده می‌شود.

## مثال قرارداد هوشمند

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol";

/**
 * @title FeedRegistryConsumer
 * @notice Demonstrates how to query a price feed using the Feed Registry.
 */
contract FeedRegistryConsumer {
    FeedRegistryInterface internal registry;

    // آدرس Feed Registry در شبکه اصلی
    address constant FEED_REGISTRY_ADDRESS = 0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf;
    
    // آدرس توکن LINK در شبکه اصلی
    address constant LINK_TOKEN = 0x514910771AF9Ca656af840dff83E8264EcF986CA;
    
    // قرارداد Denominations آدرس رسمی دارایی‌هایی مثل USD را فراهم می‌کند.
    // آدرس USD در شبکه اصلی
    address constant USD = 0x0000000000000000000000000000000000000348;

    constructor() {
        registry = FeedRegistryInterface(FEED_REGISTRY_ADDRESS);
    }

    /**
     * @notice Gets the latest LINK/USD price via the registry.
     * @return The latest price of LINK in USD.
     */
    function getLinkUsdPrice() public view returns (int256) {
        // prettier-ignore
        (
            /* uint80 roundId */,
            int256 answer,
            /* uint256 startedAt */,
            /* uint256 updatedAt */,
            /* uint80 answeredInRound */
        ) = registry.latestRoundData(LINK_TOKEN, USD);
        
        return answer;
    }
}
~~~~

## ملاحظات تازگی داده‌ها

هنگام استفاده از اوراکل‌های مبتنی بر مدل Push مانند Chainlink، توسعه‌دهندگان به‌طور ضمنی موظف به حفظ یکپارچگی داده هستند.

### سادگی فریبنده

فراخوانی `latestRoundData()` ساده است، اما در پس این سادگی یک مسئولیت مهم نهفته است: **اعتبارسنجی داده بازگشتی**.

### اعتبارسنجی تازگی

مقدار `answer` فقط زمانی معتبر است که **تازه** باشد. قرارداد مصرف‌کننده باید `updatedAt` را با `block.timestamp` مقایسه کند تا از تازه بودن داده اطمینان حاصل کند.

دلایل کهنه بودن داده ممکن است شامل موارد زیر باشد:

- ازدحام شبکه
- خرابی جزئی شبکه اوراکل
- اختلال در Sequencer لایه دوم

### اعتبارسنجی ضروری در زنجیره

قراردادها باید:

1. `updatedAt` را از پاسخ اوراکل استخراج کنند.
2. آن را با زمان بلاک جاری مقایسه کنند.
3. اگر داده قدیمی‌تر از حد قابل قبول بود آن را رد کنند.

### الزامات خاص L2

در شبکه‌های لایه دوم، بررسی اضافی باید با استفاده از **L2 Sequencer Uptime Feed** انجام شود تا:

- اطمینان حاصل شود Sequencer فعال است.
- از استفاده از قیمت‌های کهنه در زمان اختلال جلوگیری شود.

### پیامد امنیتی

عدم انجام این بررسی‌ها یک آسیب‌پذیری بحرانی ایجاد می‌کند. در واقع امنیت برنامه شما به زنده بودن شبکه اوراکل واگذار می‌شود بدون هیچ مکانیزم پشتیبانی.

همیشه با این فرض طراحی کنید که سامانه‌های خارجی ممکن است از کار بیفتند — و به درستی اعتبارسنجی انجام دهید.

---

# پیاده‌سازی فیدهای قیمتی مدل Pull با شبکه Pyth

این راهنما مدل به‌روزرسانی درخواستی برای برنامه‌های حساس به تأخیر را توضیح می‌دهد که توسط شبکه Pyth به عنوان اوراکل طرف اول اجرا می‌شود.

## مقدمه‌ای بر جریان کاری مدل Pull

مدل Pull تولید داده‌های امضا شده قیمت را از مصرف آن‌ها روی زنجیره جدا می‌کند. این مدل شامل دو محیط است:

### خارج از زنجیره

- فرانت‌اند یا بک‌اند یک dApp، داده `priceUpdateData` را که با رمزنگاری امضا شده است از یک نقطه پایانی عمومی اوراکل (مانند Hermes در Pyth) دریافت می‌کند.
- این داده شامل قیمت‌های به‌روز برای یک یا چند دارایی است.

### روی زنجیره

- `priceUpdateData` به عنوان یک آرگومان calldata به یک تابع قرارداد ارسال می‌شود.
- قرارداد هوشمند از این داده برای به‌روزرسانی وضعیت قیمت روی زنجیره استفاده کرده و در همان تراکنش قیمت را می‌خواند.

## ادغام فیدهای قیمت Pyth

برای استفاده از Pyth، ابتدا SDK آن را نصب کنید:

~~~~bash
npm install @pythnetwork/pyth-sdk-solidity
~~~~

### مؤلفه‌های اصلی

- `IPyth.sol`: واسطی برای تعامل با قرارداد Pyth در زنجیره مورد نظر.
- `PythStructs.sol`: ساختارهای داده مورد استفاده Pyth را تعریف می‌کند، به‌ویژه `Price` که شامل موارد زیر است:
  - `price`
  - `confidence`
  - `exponent`
  - `publishTime`

## فرایند سه‌مرحله‌ای روی زنجیره

هر تابع قرارداد هوشمندی که از قیمت Pyth استفاده می‌کند باید این مراحل را دنبال کند:

### 1. دریافت هزینه

برای دریافت هزینه لازم برای به‌روزرسانی قیمت:

~~~~solidity
uint256 fee = pyth.getUpdateFee(priceUpdateData);
~~~~

این هزینه برای Relayerهایی است که پیام‌های Wormhole را ارسال می‌کنند.

### 2. به‌روزرسانی قیمت‌ها

استفاده از تابع `updatePriceFeeds` برای ارسال داده و هزینه:

~~~~solidity
pyth.updatePriceFeeds{value: fee}(priceUpdateData);
~~~~

- این تابع امضاها را از طریق Wormhole اعتبارسنجی می‌کند.
- در صورت اعتبار، داده قیمت روی زنجیره به‌روزرسانی می‌شود.

### 3. خواندن قیمت

پس از به‌روزرسانی، می‌توان قیمت را به یکی از روش‌های زیر خواند:

~~~~solidity
PythStructs.Price memory price = pyth.getPrice(priceId);
~~~~

یا برای تضمین تازه بودن داده:

~~~~solidity
PythStructs.Price memory price = pyth.getPriceNoOlderThan(priceId, maxAge);
~~~~

- `priceId`: شناسه یکتای دارایی.
- `maxAge`: بیشترین مدت زمانی که قیمت معتبر است (به ثانیه).

## خلاصه

با ادغام مدل Pull در Pyth، توسعه‌دهندگان می‌توانند:

- داده قیمت را در لحظه دریافت کنند.
- فید قیمت را روی زنجیره تأیید و به‌روزرسانی کنند.
- از عملکرد ایمن برنامه‌های حساس به تأخیر اطمینان حاصل کنند.

---

# راهنمای قرارداد مصرف‌کننده Pyth

## مرور کلی

این راهنما نشان می‌دهد که چگونه داده قیمت BTC/USD را با استفاده از Pyth در Solidity مصرف کنیم. قرارداد `PythConsumer` شامل موارد زیر است:

- دریافت هزینه به‌روزرسانی قیمت
- ارسال داده قیمت امضاشده
- خواندن قیمت جدید روی زنجیره
- استفاده از قیمت و دامنه اطمینان در منطق قرارداد

## قرارداد Solidity مصرف‌کننده Pyth

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@pythnetwork/pyth-sdk-solidity/IPyth.sol";
import "@pythnetwork/pyth-sdk-solidity/PythStructs.sol";

contract PythConsumer {
    IPyth internal pyth;
    bytes32 constant BTC_USD_PRICE_ID = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43;

    constructor(address _pythContractAddress) {
        pyth = IPyth(_pythContractAddress);
    }

    function executeWithBtcPrice(bytes calldata _priceUpdateData) public payable {
        uint256 fee = pyth.getUpdateFee(_priceUpdateData);
        pyth.updatePriceFeeds{value: fee}(_priceUpdateData);

        PythStructs.Price memory currentPrice = pyth.getPriceNoOlderThan(BTC_USD_PRICE_ID, 60);

        int256 priceValue = currentPrice.price;
        int256 confidence = currentPrice.conf;

        // می‌توانید از priceValue و confidence در منطق قرارداد استفاده کنید.
    }
}
~~~~

## بحث معماری: مدل Pull در مقابل مدل Push

- مدل **Pull** یک تغییر معماری عمده در نحوه ادغام اوراکل‌ها است.
- برخلاف مدل **Push** که اوراکل‌ها خودشان قیمت را روی زنجیره به‌روزرسانی می‌کنند، در مدل Pull این dApp است که به‌روزرسانی را آغاز می‌کند.

### مزایای مدل Pull

1. **انتقال عملیات پرهزینه**:
   - شبکه اوراکل فقط داده را خارج از زنجیره امضا می‌کند.
   - تحویل نهایی به زنجیره بر عهده قرارداد مصرف‌کننده است.

2. **عملکرد بهتر**:
   - توسعه‌دهنده تعیین می‌کند که چه زمانی و چه چیزی به‌روزرسانی شود.
   - مناسب برای برنامه‌های پرتکرار مانند ترید، آپشن و وام‌دهی.

3. **دسترسی به داده‌های بیشتر**:
   - به دلیل تقاضا محور بودن، پوشش دارایی بیشتری دارد.
   - dAppها می‌توانند داده موردنیاز خود را انتخاب کنند.

4. **استفاده بالغ و تخصصی**:
   - مناسب برای DeFi با کنترل دقیق و دقت بالا در لحظه.

### معایب

- **ادغام پیچیده‌تر** (هزینه، گرفتن داده بیرونی)
- نیاز به طراحی دقیق برای مدیریت فراخوانی‌ها

## خلاصه

- قرارداد `PythConsumer` نحوه دسترسی امن به قیمت لحظه‌ای BTC/USD با استفاده از مدل Pull را نشان می‌دهد.
- مزایای زیادی برای توسعه‌دهندگان دارد: کنترل دقیق، عملکرد بالا، و انعطاف‌پذیری در داده.
- این مدل نشان‌دهنده تکامل تخصصی طراحی اوراکل برای برنامه‌های نسل جدید است.

---
# ادغام راهکارهای جایگزین اوراکل

فراتر از مدل‌های اصلی Push و Pull که توسط Chainlink و Pyth ارائه شده‌اند، ارائه‌دهندگان دیگر اوراکل نیز فلسفه‌های معماری متفاوتی را ارائه می‌دهند.

در این بخش به دو نمونه از این جایگزین‌ها می‌پردازیم: **Band Protocol** و **API3** که رویکردهای متفاوتی نسبت به داده‌های میان‌زنجیره‌ای و کاهش اعتماد ارائه می‌دهند.

---

## Band Protocol: میان‌زنجیره‌ای و قابل سفارشی‌سازی

### معماری

Band Protocol یک اوراکل میان‌زنجیره‌ای است که روی بلاک‌چین اختصاصی خود به نام **BandChain** اجرا می‌شود که با استفاده از **Cosmos SDK** ساخته شده است.

این طراحی با هدف انتقال وظایف سنگین محاسباتیِ استخراج و تجمیع داده‌ها از زنجیره مقصد EVM انجام شده است تا:

- مقیاس‌پذیری را افزایش دهد
- احتمال ازدحام شبکه را کاهش دهد

این معماری به‌صورت خاص برای **بی‌طرفی نسبت به بلاک‌چین‌ها** طراحی شده و یک راهکار همه‌منظوره برای اکوسیستم‌های چندزنجیره‌ای ارائه می‌دهد.

---

### مکانیزم

در زنجیره‌های EVM، توسعه‌دهندگان از طریق قرارداد `StdReferenceProxy` با فیدهای داده Band Protocol تعامل می‌کنند که رابط `IStdReference` را ارائه می‌دهد.

تفاوت کلیدی با رجیستری Chainlink در این است که Band دارایی‌ها را با **نمادهای رشته‌ای** (مانند `"BTC"`، `"ETH"`، `"USD"`) شناسایی می‌کند، نه آدرس توکن.

این رابط از موارد زیر پشتیبانی می‌کند:

- **پرس‌وجوی قیمت تکی** برای جفت دارایی‌ها
- **پرس‌وجوی دسته‌ای** برای کارایی بیشتر گس در یک تراکنش

### مثال کد: مصرف‌کننده Band Protocol

قرارداد زیر نحوه گرفتن قیمت‌های تکی و چندگانه از Band Protocol را نشان می‌دهد.

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// یک رابط ساده‌شده برای قرارداد Standard Reference Band Protocol
interface IStdReference {
    struct ReferenceData {
        uint256 rate; // نرخ تبدیل base/quote ضربدر 1e18
        uint256 lastUpdatedBase; // زمان آخرین به‌روزرسانی قیمت base
        uint256 lastUpdatedQuote; // زمان آخرین به‌روزرسانی قیمت quote
    }

    function getReferenceData(string calldata _base, string calldata _quote)
        external
        view
        returns (ReferenceData memory);

    function getReferenceDataBulk(string calldata _bases, string calldata _quotes)
        external
        view
        returns (ReferenceData memory);
}

contract BandConsumer {
    IStdReference internal ref;

    constructor(address _refAddress) {
        ref = IStdReference(_refAddress);
    }

    function getSinglePrice() public view returns (uint256) {
        IStdReference.ReferenceData memory data = ref.getReferenceData("BTC", "USD");
        return data.rate;
    }

    function getBulkPrices() public view returns (uint256 memory) {
        string memory bases = new string(2);
        bases = "BTC";
        bases = "ETH";

        string memory quotes = new string(2);
        quotes = "USD";
        quotes = "USD";

        IStdReference.ReferenceData memory rates = ref.getReferenceDataBulk(bases, quotes);
        
        uint256 memory prices = new uint256(2);
        prices = rates.rate;
        prices = rates.rate;

        return prices;
    }
}
~~~~

---

# API3: اوراکل‌های طرف اول و Airnode

## معماری

API3 بازنگری بنیادینی در مدل اوراکل‌ها ارائه می‌دهد. به جای تکیه بر شبکه‌ای از واسطه‌های ثالث برای ارسال داده، API3 این امکان را فراهم می‌کند که **خود ارائه‌دهندگان داده** نودهای اوراکل خود را با نام **Airnode** راه‌اندازی کنند.

این مدل، معماری **اوراکل طرف اول** را شکل می‌دهد، که یک پل مستقیم و امضاشده بین منبع API و قرارداد هوشمند روی زنجیره برقرار می‌کند.

---

## منطق پشت آن

این رویکرد برای حل آنچه API3 "مسئله اتصال API" می‌نامد طراحی شده است، نه صرفاً "مسئله اوراکل". با حذف لایه گره‌های واسط، این مدل به دنبال اهداف زیر است:

- افزایش شفافیت منبع داده
- حذف خطر دست‌کاری داده توسط واسطه
- کاهش هزینه‌ها از طریق حذف کارمزد واسطه‌ها

Airnode یک بسته‌بندی سبک، بدون سرور و **"راه‌اندازی کن و فراموش کن"** است که به راحتی توسط ارائه‌دهندگان API سنتی بدون نیاز به دانش بلاک‌چین یا مدیریت رمزارز قابل استفاده است.

---

## مکانیزم

برای توسعه‌دهندگان dApp، رایج‌ترین روش استفاده از داده‌ها، استفاده از **dAPI (API غیرمتمرکز)** است که فیدهای داده روی زنجیره‌ای هستند که از چندین Airnode طرف اول جمع‌آوری می‌شوند.

تعامل معمولاً از طریق یک قرارداد پروکسی با رابط ساده **IProxy** انجام می‌شود که مقدار به‌روز را در دسترس قرار می‌دهد.

---

## مثال کد: مصرف‌کننده dAPI از API3

این مثال نحوه خواندن یک مقدار از dAPI و استفاده از یک آداپتور برای سازگاری با رابط Chainlink را نشان می‌دهد.

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// رابط برای یک پروکسی dAPI در API3
interface IProxy {
    function read() external view returns (int256 value);
    function readWithTimestamp() external view returns (int256 value, uint32 timestamp);
}

// رابط Chainlink Aggregator برای آداپتور
interface AggregatorV3Interface {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function decimals() external view returns (uint8);
}

// مصرف‌کننده ساده برای dAPI
contract Api3Consumer {
    IProxy internal dapiProxy;

    constructor(address _proxyAddress) {
        dapiProxy = IProxy(_proxyAddress);
    }

    function getLatestDapiValue() public view returns (int256, uint32) {
        return dapiProxy.readWithTimestamp();
    }
}

// آداپتور برای سازگاری dAPI با رابط Chainlink
contract Api3Adapter is AggregatorV3Interface {
    IProxy public immutable api3Proxy;
    uint8 public immutable dapiDecimals;

    constructor(address _proxyAddress, uint8 _decimals) {
        api3Proxy = IProxy(_proxyAddress);
        dapiDecimals = _decimals;
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        (answer, uint32 timestamp) = api3Proxy.readWithTimestamp();
        updatedAt = timestamp;
        return (0, answer, 0, updatedAt, 0);
    }

    function decimals() external view override returns (uint8) {
        return dapiDecimals;
    }
}
~~~~

## مدل‌های اعتماد و طیف تمرکززدایی

تنوع در معماری‌های اوراکل نشان می‌دهد که **تمرکززدایی** یک مفهوم مطلق نیست، بلکه طیفی از مدل‌های اعتماد است.

اوراکل‌های سنتی مانند Chainlink و Band Protocol فرآیند گزارش‌دهی داده را غیرمتمرکز می‌کنند؛ اعتماد در اینجا بر پایه مشوق‌های اقتصادی و اجماع میان اپراتورهای مستقل است.

در مقابل، اوراکل‌های طرف اول فرآیند تولید داده را غیرمتمرکز می‌کنند.

مدل Pyth بر اعتماد به اعتبار جمعی و مشارکت مالی مؤسسات مالی بزرگ به عنوان ناشران داده تکیه دارد.

API3 حتی یک قدم جلوتر می‌رود و بر اعتماد مستقیم به خود منبع داده که داده را امضا می‌کند تأکید دارد.

وقتی توسعه‌دهنده‌ای یک اوراکل را انتخاب می‌کند، در واقع تصمیمی اساسی در مورد وضعیت امنیتی برنامه خود می‌گیرد:

آیا به شبکه‌ای از گزارش‌دهندگان ناشناس ولی دارای وثیقه اعتماد می‌کند؟

یا به کنسرسیومی از نهادهای معتبر؟

یا به خود منبع داده؟

این انتخاب مدل اعتماد به اندازه انتخاب فناوری اهمیت دارد.

---

# بهترین روش‌های امنیتی برای ادغام اوراکل

ادغام اوراکل یک وابستگی خارجی ایجاد می‌کند که سطح حمله قرارداد هوشمند را گسترش می‌دهد. ادغام ناامن اوراکل یکی از رایج‌ترین و اغلب فاجعه‌بارترین بردارهای آسیب‌پذیری در DeFi است.

پایبندی به شیوه‌های امنیتی سخت‌گیرانه، اختیاری نیست بلکه برای ساخت برنامه‌ای مقاوم ضروری است.

---

## اعتبارسنجی داده‌های ورودی

قرارداد نباید هرگز به‌طور کورکورانه به داده بازگشتی از اوراکل اعتماد کند. تمام داده‌های ورودی باید قبل از استفاده در منطق حیاتی، مورد بررسی‌های درون‌زنجیره‌ای قرار گیرند.

### بررسی تازگی

مهم‌ترین بررسی، اطمینان از تازه بودن داده است. ممکن است شبکه اوراکل دچار اختلال شود یا تحت تأثیر ازدحام شدید شبکه بلاک‌چین قرار گیرد و نتواند داده‌ها را به‌روز کند. استفاده از قیمت کهنه می‌تواند منجر به ارزش‌گذاری نادرست و آسیب‌پذیری پروتکل شود.

**پیاده‌سازی:** همیشه زمان بازگشتی از اوراکل (`updatedAt`، `lastUpdatedBase` و غیره) را با زمان فعلی بلاک (`block.timestamp`) مقایسه کنید. اگر اختلاف بیشتر از یک حد مجاز باشد (مثلاً بیش از یک ساعت برای پروتکل وام‌دهی)، تراکنش باید Revert شود.

~~~~solidity
require(block.timestamp - updatedAt <= 3600, "Price data is stale");
~~~~

---

### بررسی معقول بودن داده

حتی اگر تازه باشد، ممکن است قیمت دست‌کاری شده یا اشتباه باشد. قرارداد باید بررسی‌های پایه‌ای روی خود مقدار انجام دهد.

**پیاده‌سازی:** اطمینان حاصل شود که قیمت بازگشتی در یک بازه معقول قرار دارد. در حداقل حالت، بررسی شود که قیمت بیشتر از صفر باشد. برای محافظت قوی‌تر، می‌توان قیمت قبلی را ذخیره کرد و اگر قیمت جدید انحراف غیرمنتظره‌ای نسبت به قبل داشت، تراکنش را Revert کرد. این روش می‌تواند در برابر برخی حملات دست‌کاری قیمت با فلش‌لون محافظت کند.

~~~~solidity
require(price > 0, "Invalid price");
~~~~


## آگاهی از اعشار و واحدها  
اوراکل‌ها قیمت‌ها را به‌صورت اعداد صحیح مقیاس‌شده برمی‌گردانند تا از محاسبات اعشاری اجتناب شود. اگر تطابقی بین تعداد ارقام اعشار مورد انتظار توسط قرارداد و تعداد ارقام اعشار ارائه‌شده توسط اوراکل وجود نداشته باشد، منجر به محاسبات اشتباه شدیدی خواهد شد.

**پیاده‌سازی**: همیشه تعداد ارقام اعشار یک فید مشخص را از مستندات رسمی اوراکل بررسی کنید. بسیاری از قراردادهای اوراکل همچنین یک تابع عمومی به نام `decimals()` برای بررسی درون‌زنجیره‌ای فراهم می‌کنند. تمام محاسبات مربوط به قیمت باید این عامل مقیاس را در نظر بگیرند.

# مقاومت معماری  
فراتر از اعتبارسنجی داده‌ها، قرارداد باید به گونه‌ای طراحی شود که در برابر خطاهای اوراکل مقاوم باشد.

## تماس‌های خارجی دفاعی  
یک تماس خارجی به قرارداد اوراکل می‌تواند به دلایل مختلفی شکست بخورد: اوراکل ممکن است برای ارتقا متوقف شده باشد، تراکنش ممکن است از گس خالی شود، یا قرارداد ممکن است دیگر وجود نداشته باشد. اگر چنین تماسی به‌درستی مدیریت نشود، می‌تواند باعث بازگشت کل تابع قرارداد مصرف‌کننده شود و منجر به حمله Denial of Service (DoS) شود که در آن توابع حیاتی برنامه غیرقابل استفاده می‌شوند.

**پیاده‌سازی**: تمام تماس‌های خارجی با اوراکل را در یک بلوک `try/catch` قرار دهید. این امکان را فراهم می‌کند تا قرارداد بتواند تماس شکست‌خورده را به‌صورت نرم مدیریت کند. سپس قرارداد می‌تواند با پیامی خطای واضح‌تر بازگشت دهد، سعی کند از مکانیزم جایگزین استفاده کند، یا در صورت اجازه منطق، بدون داده ادامه دهد و در نتیجه کنترل جریان اجرای خود را حفظ کند.

## قطع‌کننده‌های مدار (Circuit Breakers)  
برای پروتکل‌های با ارزش بالا، عاقلانه است که مکانیزمی برای متوقف کردن توابع حیاتی در شرایط اضطراری پیاده‌سازی شود.

**پیاده‌سازی**: یک تابع کنترل‌شده توسط حاکمیت یا مالک را اضافه کنید که بتواند عملکردهایی از قرارداد را که وابسته به اوراکل هستند متوقف کند. اگر یک ناهنجاری بزرگ قیمتی یا اختلال در اوراکل به‌صورت برون‌زنجیره‌ای شناسایی شد، این «قطع‌کننده مدار» می‌تواند فعال شود تا از خالی شدن یا بهره‌برداری از پروتکل جلوگیری شود تا مشکل بررسی و رفع گردد.

## اوراکل‌های جایگزین  
برای ایجاد افزونگی، برنامه‌های با ارزش بالا می‌توانند بیش از یک ارائه‌دهنده اوراکل مستقل را یکپارچه کنند.

**پیاده‌سازی**: اگر داده‌های اوراکل اصلی آزمون‌های اعتبارسنجی را رد کردند (مثلاً داده کهنه یا خارج از محدوده است)، قرارداد می‌تواند تلاش کند داده را از اوراکل ثانویه دریافت کند. در حالی که این کار مقاومت را به‌شدت افزایش می‌دهد، پیچیدگی و هزینه گس را نیز زیاد می‌کند و نیاز به مدیریت دقیق دارد که کدام اوراکل مورد اعتماد است اگر قیمت‌های معتبر آن‌ها متفاوت باشند.

# درک ریسک‌های سیستمی  
توسعه‌دهندگان همچنین باید ریسک‌های سیستمی ذاتی در طراحی اوراکل را در نظر بگیرند.

## بردارهای دستکاری قیمت  
امنیت داده‌های یک اوراکل فقط به اندازه منابع آن قوی است. اگر اوراکل قیمت خود را از قیمت اسپات یک دارایی در یک صرافی غیرمتمرکز با نقدینگی پایین دریافت کند، ممکن است در معرض دستکاری قیمت قرار گیرد. یک مهاجم می‌تواند از وام فلش برای انجام معامله‌ای بزرگ استفاده کند که قیمت اسپات را موقتاً منحرف می‌کند، اوراکل این قیمت دستکاری‌شده را گزارش می‌دهد و سپس آن را برای بهره‌برداری از پروتکل هدف استفاده می‌کند (مثلاً با گرفتن وام علیه وثیقه با ارزش جعلی).

**راهکار**: از اوراکل‌هایی استفاده کنید که داده‌ها را از منابع مختلف، باکیفیت و دارای نقدینگی بالا تجمیع می‌کنند. اوراکل‌هایی که از میانگین‌های وزنی بر اساس حجم (VWAP) استفاده می‌کنند، نسبت به دستکاری مقاوم‌تر هستند تا اوراکل‌هایی که فقط از قیمت اسپات استفاده می‌کنند. میانگین‌های وزنی زمانی (TWAP) نیز گزینه‌ای قوی هستند، زیرا قیمت‌ها را در طول زمان میانگین‌گیری می‌کنند و دستکاری لحظه‌ای را بسیار سخت‌تر و پرهزینه‌تر می‌سازند، هرچند این باعث افزایش تأخیر می‌شود.

## ریسک‌های حاکمیتی و قابلیت ارتقا  
مدل حاکمیتی یک شبکه اوراکل می‌تواند بردار حمله باشد. یک توسعه‌دهنده باید بداند چه کسی قدرت ارتقای قراردادهای درون‌زنجیره‌ای اوراکل، تغییر پارامترهای کلیدی (مثل آستانه انحراف)، یا اضافه/حذف اپراتورهای نود را دارد. یک فرایند حاکمیتی مخرب یا به‌خطر‌افتاده می‌تواند مستقیماً تمام برنامه‌های وابسته را تهدید کند.

**راهکار**: مستندات اوراکل را درباره ساختار حاکمیتی آن و اختیارات نقش‌های مدیریتی بررسی کنید. از اوراکل‌هایی با فرایندهای حاکمیتی شفاف و محدودیت زمانی برای تغییرات حیاتی استفاده کنید.

## مدل مسئولیت مشترک  
تصور رایج اشتباهی بین توسعه‌دهندگان وجود دارد که انتخاب یک ارائه‌دهنده اوراکل معتبر آن‌ها را از مسئولیت امنیتی معاف می‌کند. این اشتباه است.

رابطه بین dApp و اوراکل مانند مدل مسئولیت مشترک در رایانش ابری است:

شبکه اوراکل مسئول امنیت اوراکل است — یعنی تضمین تمرکززدایی نودها، کیفیت داده‌ها، و در دسترس بودن.

توسعه‌دهنده dApp مسئول امنیت در استفاده از داده‌های آن اوراکل است.

قرارداد مصرف‌کننده باید سیاست امنیتی خود را از طریق اعتبارسنجی دقیق هر داده‌ای که دریافت می‌کند اعمال کند. ناتوانی در بررسی کهنگی، سلامت یا اعشار صحیح، یک آسیب‌پذیری در قرارداد مصرف‌کننده است، نه لزوماً مشکل در اوراکل.

امنیت واگذار نمی‌شود؛ بلکه تلاش مشترک و یکپارچه است.

---

# خدمات پیشرفته اوراکل: تصادفی‌سازی قابل‌راستی‌آزمایی  

فراتر از ارائه فیدهای داده، شبکه‌های اوراکل طیف گسترده‌ای از خدمات محاسباتی خارج از زنجیره را فراهم می‌کنند. یکی از مهم‌ترین آن‌ها، ارائه اعداد تصادفی منصفانه و قابل‌راستی‌آزمایی است — کاری که تأمین ایمن آن در یک بلاکچین قطعی، دشوار و فریبنده است.

---

## مسئله تصادفی‌سازی درون‌زنجیره‌ای  

بلاکچین‌ها ذاتاً قطعی هستند؛ هر نود باید هر تراکنش را دوباره اجرا کند و به همان وضعیت برسد تا اجماع حفظ شود. این قطعی بودن ذاتی، تولید تصادفی واقعی و غیرقابل‌پیش‌بینی به‌صورت مستقیم درون‌زنجیره را غیرممکن می‌سازد.

تلاش‌های ساده‌لوحانه برای تأمین تصادفی از متغیرهای درون‌زنجیره‌ای مانند `block.timestamp` یا `blockhash` اساساً ناامن هستند. این مقادیر تا حدی قابل‌پیش‌بینی هستند یا می‌توانند توسط تولیدکنندگان بلاک (ماینرها یا اعتبارسنج‌ها) تحت‌تأثیر قرار بگیرند که ممکن است بلاک‌هایی با نتایج نامطلوب را کنار بگذارند تا به خود یا دیگران سود برسانند.

بنابراین این روش‌ها برای هر کاربردی که در آن انصاف حیاتی است، مانند بازی‌ها، قرعه‌کشی‌ها یا مینت‌های NFT تصادفی، نامناسب هستند.

---

## تابع تصادفی قابل‌راستی‌آزمایی (VRF) به‌عنوان راه‌حل  

### مفهوم  

یک تابع تصادفی قابل‌راستی‌آزمایی (VRF) یک بدیهه رمزنگاری است که راه‌حل امنی برای این مسئله فراهم می‌کند.

VRF تابعی عمومی-کلیدی است که یک ورودی (seed) و یک کلید خصوصی را می‌گیرد و یک خروجی تصادفی شبه‌تصادفی تولید می‌کند. مهم‌تر از آن، یک اثبات رمزنگاری تولید می‌کند که نشان می‌دهد این خروجی به‌درستی و اصالتاً از آن ورودی خاص با استفاده از کلید خصوصی تولید شده است.

### ویژگی‌ها  

- **قابل‌راستی‌آزمایی**: هر کسی که کلید عمومی را دارد می‌تواند با استفاده از اثبات، اعتبار عدد تصادفی را بررسی کند. این تأیید یک محاسبه قطعی است که می‌تواند درون‌زنجیره انجام شود.

- **غیرقابل‌پیش‌بینی**: خروجی به نظر تصادفی می‌رسد و برای هر کسی که کلید خصوصی را ندارد، حتی اگر seed را بداند، غیرقابل‌پیش‌بینی است.

---

## یکپارچه‌سازی اوراکل  

شبکه اوراکل غیرمتمرکز مانند Chainlink از VRF برای ارائه خدمات تصادفی‌سازی مقاوم در برابر دستکاری به قراردادهای هوشمند استفاده می‌کند. این فرآیند شامل یک چرخه درخواست-پاسخ است که در آن قرارداد هوشمند درخواست عدد تصادفی می‌دهد، و نود اوراکل عدد و اثبات آن را خارج از زنجیره با استفاده از کلید خصوصی خود تولید می‌کند.

سپس نود تراکنشی به قرارداد مصرف‌کننده ارسال می‌کند که اثبات را بررسی کرده و در صورت صحت، عدد تصادفی را استفاده می‌کند.

---

## پیاده‌سازی Chainlink VRF  

جریان کاری Chainlink VRF نسخه ۲ مبتنی بر مدل اشتراک است. توسعه‌دهنده یک حساب اشتراک را با توکن‌های LINK تأمین مالی می‌کند، و قراردادهای مصرف‌کننده آن به‌عنوان مصرف‌کنندگان مجاز افزوده می‌شوند.

### جریان کاری

1. قرارداد مصرف‌کننده درخواستی برای اعداد تصادفی به قرارداد VRF Coordinator درون‌زنجیره‌ای ارسال می‌کند.

2. نود اوراکل Chainlink این درخواست را دریافت می‌کند.

3. نود اوراکل پس از تعداد مشخصی از تأیید بلاک، عدد تصادفی و اثبات آن را تولید می‌کند.

4. نود تراکنشی را به Coordinator ارسال می‌کند که اثبات را بررسی می‌کند.

5. اگر اثبات معتبر باشد، Coordinator تابع `fulfillRandomWords` را در قرارداد مصرف‌کننده فراخوانی می‌کند.

---

## مثال کد: مصرف‌کننده Chainlink VRF

قرارداد زیر ساختار پایه‌ای برای درخواست و دریافت اعداد تصادفی از Chainlink VRF v2 را نشان می‌دهد.

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";

contract VrfConsumer is VRFConsumerBaseV2 {
    VRFCoordinatorV2Interface COORDINATOR;

    uint64 s_subscriptionId;
    address vrfCoordinator;
    bytes32 keyHash;

    uint16 constant REQUEST_CONFIRMATIONS = 3;
    uint32 constant NUM_WORDS = 2;

    uint256 public s_randomWords;
    uint256 public s_lastRequestId;

    event RequestSent(uint256 requestId, uint32 numWords);
    event RequestFulfilled(uint256 requestId, uint256 randomWords);

    constructor(uint64 subscriptionId, address _vrfCoordinator, bytes32 _keyHash) VRFConsumerBaseV2(_vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);
        s_subscriptionId = subscriptionId;
        vrfCoordinator = _vrfCoordinator;
        keyHash = _keyHash;
    }

    function requestRandomWords() public {
        s_lastRequestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            REQUEST_CONFIRMATIONS,
            500000,
            NUM_WORDS
        );
        emit RequestSent(s_lastRequestId, NUM_WORDS);
    }

    function fulfillRandomWords(uint256 _requestId, uint256 memory _randomWords) internal override {
        s_randomWords = _randomWords;
        emit RequestFulfilled(_requestId, s_randomWords);
    }
}
~~~~

---

# موارد استفاده و جایگزین‌های تصادفی‌سازی قابل‌راستی‌آزمایی

تصادفی‌سازی قابل‌راستی‌آزمایی یکی از اجزای پایه‌ای برای طیف گسترده‌ای از برنامه‌های زنجیره‌ای است. این ویژگی حیاتی است برای:

---

## موارد استفاده  

- **بازی‌های بلاکچینی**:  
  تولید نتایج منصفانه و غیرقابل‌پیش‌بینی مانند افتادن آیتم‌ها در loot box، ایجاد نقشه تصادفی یا تعیین احتمال ضربه‌های بحرانی.

- **NFTها**:  
  تعیین صفات و ویژگی‌های تصادفی هنگام مینت برای ایجاد کمیابی و منحصر به‌فرد بودن، مانند پروژه‌هایی مثل Bored Ape Yacht Club.

- **انتخاب منصفانه**:  
  هر فرآیندی که نیاز به انتخاب تصادفی و بی‌طرفانه افراد دارد، مانند انتخاب برندگان قرعه‌کشی، انتخاب اعضای هیئت منصفه در دادگاه غیرمتمرکز یا توزیع دارایی‌های کمیاب.

---

## جایگزین‌های اوراکل برای تصادفی‌سازی

سایر ارائه‌دهندگان اوراکل نیز راه‌حل‌های جایگزینی برای تصادفی‌سازی ارائه می‌دهند، از جمله:

- **شبکه Pyth**:  
  سرویس *Pyth Entropy* را فراهم می‌کند که از یک طرح دوطرفه commit-reveal برای تولید اعداد تصادفی استفاده می‌کند.

- **Band Protocol**:  
  سرویس VRF مخصوص به خود را که بر روی BandChain ساخته شده ارائه می‌دهد.




</div>
