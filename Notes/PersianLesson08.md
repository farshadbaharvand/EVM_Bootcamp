
<div dir="rtl">

# حساب تقسیم در Solidity

درک نحوه کار تقسیم در Solidity برای جلوگیری از رفتار غیرمنتظره و خطاهای زمان اجرا ضروری است. این بخش به طور خاص بر تقسیم عدد صحیح و ویژگی‌های آن در زبان Solidity تمرکز دارد.

## رفتار تقسیم عدد صحیح

- در Solidity، **نوع نتیجه** عملیات تقسیم **همیشه همان نوع یکی از عملوندها** است.
- هنگام انجام تقسیم روی اعداد صحیح، نتیجه **به سمت صفر گرد می‌شود**.

### مثال

int256(-5) / int256(2) == int256(-2)

این رفتار با برخی زبان‌های دیگر که در چنین مواردی به سمت منفی بی‌نهایت گرد می‌کنند متفاوت است.

## تقسیم روی مقادیر ثابت (لیتریال)

- وقتی روی **اعداد ثابت** (مثلاً مقادیر ثابت مانند `5 / 2`) تقسیم انجام می‌دهید، نتیجه می‌تواند یک **مقدار کسری با دقت دلخواه** باشد.
- این در عبارات ثابت یا محاسبات زمان کامپایل کاربرد دارد، اما **برای متغیرهای عدد صحیح اعمال نمی‌شود**.

## تقسیم بر صفر

- **تقسیم بر صفر** باعث ایجاد خطای **Panic** در زمان اجرا می‌شود.
- این نوع بررسی با استفاده از بلوک‌های `unchecked { ... }` **قابل غیرفعال کردن نیست**.
- همیشه قبل از انجام تقسیم مطمئن شوید مخرج صفر نیست تا از کرش جلوگیری شود.

## خلاصه

- تقسیم عدد صحیح همیشه یک نتیجه عدد صحیح می‌دهد.
- تقسیم به سمت صفر گرد می‌شود.
- تقسیم روی مقادیر ثابت ممکن است مقادیر کسری دقیق بدهد.
- تقسیم بر صفر باعث خطای زمان اجرا می‌شود که قابل غیرفعال کردن نیست.

---

# آدرس‌ها

## راهنمای `address` و `address payable` در Solidity

نوع `address` در Solidity برای نگهداری آدرس‌های اتریوم استفاده می‌شود. دو نوع اصلی وجود دارد:

- `address`: یک آدرس ۲۰ بایتی اتریوم است. برای ارسال مستقیم اتر مناسب نیست.
- `address payable`: مانند `address` است اما با توابع داخلی (`transfer` و `send`) برای ارسال اتر.

---

## چرا این تمایز وجود دارد؟

این تمایز کمک می‌کند واضح شود که چه زمانی یک آدرس قرار است اتر دریافت کند. این موضوع امنیت قرارداد و خوانایی کد را افزایش می‌دهد.

- از نسخه **۰.۵.۰** Solidity معرفی شده است.
- همیشه وقتی می‌خواهید به آدرس اتر ارسال کنید از `address payable` استفاده کنید.

---

## تبدیل نوع‌ها

Solidity هم تبدیل ضمنی و هم تبدیل صریح بین انواع آدرس و انواع مرتبط را پشتیبانی می‌کند.

### تبدیل ضمنی
- `address payable` → `address` (به صورت خودکار مجاز است)

### تبدیل صریح
- `address` → `address payable` نیازمند:
  - `payable(address)`

### تبدیل‌های دیگر
- `uint160`، اعداد ثابت صحیح، `bytes20` و نوع قراردادها می‌توانند به صورت **صریح** به/از `address` تبدیل شوند.
- فقط `address` و نوع قراردادها می‌توانند با `payable(...)` به `address payable` تبدیل شوند.

> استثنا: `payable(0)` همیشه معتبر است.

> برای تبدیل نوع قرارداد به `address payable`، قرارداد باید تابع `receive` یا `payable fallback` داشته باشد.

---

## عملگرها با نوع‌های آدرس

می‌توانید از عملگرهای مقایسه استاندارد با آدرس‌ها استفاده کنید:

- `<`
- `<=`
- `==`
- `!=`
- `>=`
- `>`

---

## هشدار برش (Truncation)

اگر داده‌ای با نوع بزرگ‌تر مانند `bytes32` را به `address` تبدیل کنید، نتیجه **برش داده می‌شود**.

- از نسخه **۰.۴.۲۴** به بعد، کامپایلر نیازمند تأیید صریح این برش است تا سردرگمی پیش نیاید.

---

## اعضای آدرس

### ۱. `balance`
- مقدار **اتر** (برحسب wei) که توسط آدرس نگهداری می‌شود را برمی‌گرداند.

### ۲. `transfer(amount)`
- اتر را به یک آدرس قابل پرداخت ارسال می‌کند.
- برگشت به حالت قبل (revert) اگر:
  - موجودی قرارداد کافی نباشد.
  - قرارداد گیرنده انتقال را رد کند.
  - تابع فراخوانی شده گاز کافی نداشته باشد.

### ۳. `send(amount)`
- مشابه `transfer` است ولی:
  - در صورت شکست، `false` برمی‌گرداند.
  - **تراکنش را revert نمی‌کند**.
- **هشدار**: ممکن است به‌صورت خاموش شکست بخورد، بنابراین استفاده از `transfer` یا الگوی **"pull"** ایمن‌تر است.

---

### ۴. call(), delegatecall(), و staticcall()

این توابع امکان تعامل سطح پایین با قراردادهای دیگر را فراهم می‌کنند:

#### ۱. `call`
- فراخوانی سطح پایین خارجی.
- پارامترهای اختیاری `{value: مقدار، gas: مقدار}` می‌پذیرد.
- مقدار بازگشتی `(success, data)` است.

#### ۲. `delegatecall`
- کد قرارداد هدف را در **زمینه فعلی** اجرا می‌کند.
- اشتراک می‌گذارد:
  - حافظه ذخیره‌سازی (storage)
  - `msg.sender`
  - موجودی (balance)
- معمولاً برای منطق کتابخانه‌ای یا پروکسی استفاده می‌شود.

#### ۳. `staticcall`
- کد را به صورت **فقط خواندنی** اجرا می‌کند.
- اگر تغییر حالت انجام شود، revert می‌کند.

##### رمزگذاری داده‌ها

برای رمزگذاری داده در فراخوانی‌های سطح پایین از موارد زیر استفاده کنید:

- `abi.encode`
- `abi.encodePacked`
- `abi.encodeWithSelector`
- `abi.encodeWithSignature`

##### نکات

- از مقداردهی سخت‌کد شده گاز اجتناب کنید.
- فقط وقتی لازم است از این توابع سطح پایین استفاده کنید.
- برای تعاملات ایمن‌تر، ترجیحاً از فراخوانی مستقیم توابع (مثلاً `contract.functionName()`) استفاده کنید.

---

### ۵. `code` و `codehash`

#### ۱. `addr.code`
- کد بایت قرارداد را به صورت `bytes memory` بازمی‌گرداند.
- برای حساب‌های خارجی (EOA) یا قراردادهای غیر موجود خالی است.

#### ۲. `addr.codehash`
- هش `bytes32` کد قرارداد را برمی‌گرداند.
- از نظر گاز کارآمدتر از `keccak256(addr.code)` است.
- ممکن است مقادیر زیر را برگرداند:
  - `0x0` اگر آدرس خالی باشد.
  - هش رشته خالی اگر آدرس موجودی یا nonce داشته باشد اما کدی نداشته باشد.

---

## بهترین شیوه‌ها

- فقط در صورت نیاز از `address payable` استفاده کنید.
- از `send` خودداری کرده و به جای آن `transfer` یا الگوهای pull را به کار ببرید.
- مگر در موارد پروکسی یا منطق کتابخانه‌ای، از `delegatecall` استفاده نکنید.
- از تبدیل صریح برای جلوگیری از ابهام استفاده کنید.
- همیشه هنگام تبدیل نوع‌های بزرگ‌تر مراقب احتمال برش باشید.

---
# راهنمای تغییردهنده‌های تابع و نوع در Solidity

Solidity انواع مختلفی از **تغییردهنده‌ها (modifiers)** را ارائه می‌دهد که می‌توان آن‌ها را روی توابع، متغیرها و رویدادها اعمال کرد تا رفتار، دید و تعامل با ماشین مجازی اتریوم (EVM) را کنترل کند.

---

## تغییردهنده‌های تابع

### ۱. `pure`
- برای توابعی استفاده می‌شود که **نه از حالت قرارداد می‌خوانند و نه آن را تغییر می‌دهند**.
- دسترسی به متغیرهای ذخیره یا داده‌های بلاک‌چین مانند `block.timestamp` ندارند.

**مثال:**
- محاسبات ریاضی
- دستکاری رشته‌ها

### ۲. `view`
- برای توابعی است که **فقط از حالت می‌خوانند ولی تغییر نمی‌دهند**.
- اجازه می‌دهد مقادیر ذخیره شده را برگرداند.

**مثال:**
- توابع getter

### ۳. `payable`
- تابعی را مشخص می‌کند که قادر به **دریافت اتر** باشد.
- برای ارسال ETH به قرارداد با استفاده از `msg.value` لازم است.

**مثال:**
- توابع واریز
- ضرب توکن‌های NFT با هزینه

### ۴. `constant`
- برای متغیرهای حالت استفاده می‌شود که **یکبار هنگام تعریف مقداردهی شده و تغییر نمی‌کنند**.
- مقدار در بایت‌کد قرارداد جای می‌گیرد.
- **فضای ذخیره‌سازی اشغال نمی‌کند**.

**مثال:**
- `uint256 public constant VERSION = 1;`

### ۵. `immutable`
- اجازه می‌دهد متغیرهای حالت **فقط یکبار در سازنده (constructor) مقداردهی شوند**.
- پس از استقرار ثابت باقی می‌مانند.
- در **کد قرارداد** ذخیره می‌شوند، نه در حافظه ذخیره‌سازی.

**مثال:**
- آدرس مالک که هنگام استقرار تعیین می‌شود

### ۶. `anonymous`
- وقتی روی یک رویداد اعمال شود، **امضا (signature) رویداد به عنوان اولین تاپیک ذخیره نمی‌شود**.
- ثبت رویداد را کمی ارزان‌تر و فیلتر کردن را سخت‌تر می‌کند.

**کاربرد:**
- لاگ‌های مربوط به حفظ حریم خصوصی

### ۷. `indexed`
- روی پارامترهای **رویداد** اعمال می‌شود.
- پارامتر را به صورت **تاپیک** ذخیره می‌کند تا فیلتر کردن در رابط کاربری یا Web3 آسان‌تر شود.

**توجه:**
- حداکثر ۳ پارامتر قابل ایندکس شدن هستند.

### ۸. `virtual`
- تابع یا تغییردهنده‌ای را به صورت **قابل بازنویسی (override)** در قراردادهای فرزند مشخص می‌کند.

**کاربرد:**
- متدهای قرارداد پایه که قرار است سفارشی‌سازی شوند

### ۹. `override`
- نشان می‌دهد تابع، تغییردهنده یا متغیر عمومی، **پیاده‌سازی قرارداد والد را جایگزین می‌کند**.

**کاربرد:**
- هنگام بازنویسی توابع `virtual` از قرارداد پایه ضروری است.

---

## جدول خلاصه

| تغییردهنده  | اعمال بر روی       | توضیح                                                               |
|-------------|--------------------|--------------------------------------------------------------------|
| `pure`      | تابع               | خواندن یا تغییر حالت قرارداد را غیرمجاز می‌کند                   |
| `view`      | تابع               | تغییر حالت قرارداد را غیرمجاز می‌کند                              |
| `payable`   | تابع               | اجازه دریافت اتر می‌دهد                                            |
| `constant`  | متغیر حالت         | بعد از مقداردهی اولیه قابل تغییر نیست؛ در بایت‌کد ذخیره می‌شود    |
| `immutable` | متغیر حالت         | فقط در سازنده مقداردهی می‌شود؛ ثابت باقی می‌ماند؛ در بایت‌کد ذخیره می‌شود |
| `anonymous` | رویداد             | امضای رویداد را از لیست تاپیک‌ها حذف می‌کند                       |
| `indexed`   | پارامتر رویداد     | امکان فیلتر لاگ‌ها بر اساس پارامتر را فراهم می‌کند                |
| `virtual`   | تابع/تغییردهنده   | قابل بازنویسی در قراردادهای فرزند است                             |
| `override`  | تابع/تغییردهنده/متغیر | پیاده‌سازی عضو `virtual` والد را جایگزین می‌کند                   |

---

# حلقه‌ها در Solidity

در Solidity، حلقه‌ها اجازه می‌دهند تا یک بلوک کد به طور مکرر اجرا شود. این برای پیمایش آرایه‌ها، انجام محاسبات چندباره یا انتظار برای برقراری یک شرط خاص مفید است.

Solidity از انواع زیر حلقه پشتیبانی می‌کند:

---

## حلقه `for`

حلقه `for` زمانی استفاده می‌شود که دقیقاً بدانید چند بار می‌خواهید حلقه را اجرا کنید. شامل سه بخش است:

- **مقداردهی اولیه**: شمارنده حلقه را تعریف و مقداردهی می‌کند.
- **شرط**: قبل از هر بار اجرای حلقه بررسی می‌شود. اگر درست باشد حلقه ادامه می‌یابد.
- **افزایش/کاهش شمارنده**: پس از هر بار اجرا، شمارنده را به‌روزرسانی می‌کند.

### مثال: جمع اعداد از ۱ تا ۵

~~~~solidity
uint sum = 0;
for (uint i = 1; i <= 5; i++) {
    sum += i;
}
// پس از این حلقه، sum برابر ۱۵ خواهد بود
~~~~

### توضیح

- **مقداردهی اولیه**: `uint i = 1` یکبار در ابتدا اجرا می‌شود.
- **شرط**: `i <= 5` قبل از هر بار اجرا بررسی می‌شود.
- **افزایش**: `i++` پس از هر بار اجرا، مقدار i را ۱ واحد افزایش می‌دهد.

---

## حلقه `while`

حلقه `while` زمانی استفاده می‌شود که نمی‌دانید چند بار باید حلقه را اجرا کنید، اما می‌خواهید تا زمانی که یک شرط برقرار است ادامه دهید.

### مثال: دو برابر کردن عدد تا زمانی که بزرگتر از ۱۰۰ شود

~~~~solidity
uint num = 5;
while (num <= 100) {
    num *= 2;
}
// پس از این حلقه، num برابر ۱۶۰ خواهد بود
~~~~

### توضیح

- **شرط**: `num <= 100` قبل از هر بار اجرا ارزیابی می‌شود.
- اگر شرط درست باشد، بدنه حلقه اجرا می‌شود.
- اگر شرط غلط باشد، حلقه پایان می‌یابد.

---

## حلقه `do...while`

حلقه `do...while` مشابه حلقه `while` است اما تضمین می‌کند که بدنه حلقه حداقل یک بار اجرا شود، حتی اگر شرط اولیه غلط باشد.

### مثال: حلقه `do...while` که یک بار اجرا می‌شود

~~~~solidity
uint x = 10;
do {
    x++;
} while (x < 10);
// پس از این حلقه، x برابر ۱۱ خواهد بود
~~~~

### توضیح

- **بدنه حلقه**: کد داخل `do { ... }` ابتدا اجرا می‌شود.
- **شرط**: `x < 10` پس از اجرای اول بررسی می‌شود.
- اگر شرط درست باشد، حلقه ادامه می‌یابد، در غیر اینصورت متوقف می‌شود.

---

## خلاصه

| نوع حلقه      | زمان استفاده                                                   | زمان بررسی شرط     |
|---------------|----------------------------------------------------------------|--------------------|
| `for`         | وقتی تعداد دفعات اجرا مشخص است                                 | قبل از هر بار اجرا  |
| `while`       | وقتی اجرای حلقه بر اساس شرط نامعلوم است                        | قبل از هر بار اجرا  |
| `do...while`  | وقتی حداقل یک بار اجرای حلقه ضروری است                         | بعد از اولین اجرا   |

> ⚠️ نکته: حلقه‌های بیش از حد طولانی یا نامحدود در Solidity به دلیل محدودیت گاز خطرناک هستند. از حلقه روی داده‌های بزرگ در قراردادهای هوشمند خودداری کنید.

---

# دستورات کنترل حلقه در Solidity

Solidity دستورات کنترلی دارد که به توسعه‌دهندگان اجازه می‌دهد جریان حلقه‌ها مانند `for`، `while` و `do...while` را مدیریت کنند. این دستورات برای شرایطی مانند پایان زودهنگام حلقه یا رد کردن تکرارهای خاص مفید هستند.

---

### `break`

- بلافاصله از حلقه خارج می‌شود، بدون توجه به وضعیت شرط.
- کاربرد: زمانی که شرط خاصی برقرار است و ادامه حلقه غیرضروری است.

**مثال:**

~~~~solidity
for (uint i = 0; i < 10; i++) {
    if (i == 5) {
        break; // وقتی i برابر ۵ شد، حلقه را ترک می‌کند
    }
}
~~~~

---

### `continue`

- اجرای کدهای باقی‌مانده در تکرار جاری را رد می‌کند.
- مستقیماً به تکرار بعدی حلقه می‌رود.

**مثال:**

~~~~solidity
for (uint i = 0; i < 5; i++) {
    if (i == 2) {
        continue; // وقتی i برابر ۲ شد، بقیه این تکرار را رد می‌کند
    }
    // این کد وقتی i برابر ۲ باشد اجرا نمی‌شود
}
~~~~

---

## ملاحظات مهم درباره حلقه‌ها در Solidity

### ۱. هزینه گاز

- هر بار اجرای حلقه مصرف گاز دارد.
- حلقه‌های طولانی یا پیچیده می‌توانند باعث خطای تمام شدن گاز شوند.
- تعداد تکرارها را کم و بهینه نگه دارید.

### ۲. محدود بودن تعداد تکرارها

- همیشه سعی کنید حلقه‌هایی با محدودیت مشخص و ثابت بنویسید.
- از حلقه‌هایی که به داده‌های خارجی یا ورودی کاربران وابسته‌اند و ممکن است نامحدود باشند اجتناب کنید.

### ۳. خطرات دوباره‌ورود (Reentrancy)

- هنگام فراخوانی قراردادهای خارجی داخل حلقه بسیار مراقب باشید.
- این تماس‌ها ممکن است قرارداد شما را در معرض حملات دوباره‌ورود قرار دهند، خصوصاً هنگام انتقال اتر.
- الگوی پرداخت **"pull"** را استفاده کنید، جایی که دریافت‌کنندگان خود برای دریافت وجه اقدام می‌کنند نه اینکه به صورت خودکار در حلقه پرداخت شوند.

---

## خلاصه

- برای خروج زودهنگام از حلقه از `break` استفاده کنید.
- برای رد کردن تکرار جاری از `continue` بهره ببرید.
- از حلقه‌های سنگین یا نامحدود اجتناب کنید تا گاز صرفه‌جویی شده و خطا پیش نیاید.
- هرگز اتر را در حلقه بدون محافظت مناسب در برابر دوباره‌ورود ارسال نکنید.







</div>
