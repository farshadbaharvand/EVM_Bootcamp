
<div dir="rtl">

# ارث‌بری در Solidity

در برنامه‌نویسی شیءگرا، **ارث‌بری** مکانیزمی است که یک شیء یا کلاس بر اساس یک شیء یا کلاس دیگر ساخته می‌شود. شیئی که از طریق ارث‌بری ساخته شده، _شیء فرزند_، برخی یا تمام ویژگی‌ها و رفتارهای _شیء والد_ را به ارث می‌برد.

در Solidity از کلیدواژه **`is`** استفاده می‌کنیم تا نشان دهیم قرارداد جاری از قرارداد والد ارث می‌برد. برای مثال، در کد زیر، **`Destructible`** قرارداد فرزند و **`Owned`** قرارداد والد است.

## مثال پایه
~~~~solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

contract Owned {
    constructor() { owner = msg.sender; }
    address  owner;
}

// برای ارث‌بری از قرارداد دیگر از `is` استفاده می‌کنیم.
// قراردادهای مشتق‌شده می‌توانند به همه اعضای غیرخصوصی، 
// از جمله توابع داخلی و متغیرهای حالت دسترسی داشته باشند.
// این اعضا از طریق `this` از خارج قابل دسترسی نیستند.
contract Child1 is Owned {
    // کلیدواژه `virtual` به این معنی است که تابع می‌تواند 
    // در کلاس‌های فرزند تغییر رفتار داده شود ("بازنویسی").
    function doThings()) virtual public {
        .... ;
    }
}
~~~~

---

### نکات کلیدی

- کلیدواژه **`is`** برای ارث‌بری از یک قرارداد پایه استفاده می‌شود.
- قراردادهای فرزند تمام اعضای **غیرخصوصی** قرارداد والد را به ارث می‌برند.
- توابع علامت‌گذاری شده با **`virtual`** می‌توانند در قراردادهای فرزند **بازنویسی** شوند.
- توابعی که قرار است تابع والد را بازنویسی کنند باید از کلیدواژه **`override`** استفاده کنند.

## مثال ارث‌بری ERC20

Solidity همچنین از ارث‌بری قراردادهای وارد شده پشتیبانی می‌کند، مانند پیاده‌سازی ERC20 از OpenZeppelin.

~~~~solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract GLDToken is ERC20 {

    constructor(uint256 initialSupply) ERC20("Gold", "GLD") {
    
        _mint(msg.sender, initialSupply);
    
    }

}
~~~~

### توضیح

1. قرارداد `GLDToken` از قرارداد `ERC20` در OpenZeppelin ارث می‌برد.  
2. کانستراکتور والد `ERC20("Gold", "GLD")` داخل کانستراکتور `GLDToken` فراخوانی می‌شود.  
3. تابع `_mint` برای تخصیص عرضه اولیه توکن به مستقرکننده قرارداد استفاده می‌شود.

## منابع اضافی

- [ارث‌بری در Solidity — مستندات رسمی](https://docs.soliditylang.org/en/latest/contracts.html#inheritance)  
- [مخزن GitHub OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)

# Require و خطاها در Solidity

Solidity مکانیزم‌های مختلفی برای مدیریت خطا دارد: `require`، `assert`، `revert` و `try/catch`. این ابزارها برای اعتبارسنجی شرایط، تضمین پایداری و مدیریت موارد استثنایی در اجرای قراردادهای هوشمند ضروری هستند.

---

## `require`، `assert`، `revert` و `try/catch`

### `require`

تابع `require` برای:  
- اعتبارسنجی شرایطی که باید قبل از ادامه اجرای کد درست باشند.  
- بررسی ورودی توابع، متغیرهای حالت، و مقادیر بازگشتی از فراخوانی‌های خارجی.

اگر شرط برقرار نباشد، تراکنش را بازگردانی (revert) می‌کند و پیغام خطا می‌دهد، که می‌تواند:  
- یک خطای عمومی، یا  
- یک پیام خطای از نوع `Error(string)` باشد.

**کاربرد:** تضمین صحت ورودی‌ها یا شرایط خارجی در زمان اجرا.

**مثال:**
~~~~solidity
require(_amount > 0, "Amount must be > 0");
~~~~

---

### `assert`

تابع `assert` برای:  
- کشف خطاهای داخلی  
- بررسی نا‌متغیرهایی که همیشه باید برقرار باشند (invariants)

اگر شرط برقرار نباشد، خطای `Panic(uint256)` ایجاد می‌کند. قرارداد سالم نباید در شرایط معمول یا تحت تاثیر کاربر، این خطا را ایجاد کند.

**کاربرد:** اشکال‌زدایی، بررسی‌های داخلی و نا‌متغیرها.

**مثال:**
~~~~solidity
assert(a > b);
~~~~

---

### `revert`

عبارت `revert` اجرای تابع را متوقف کرده و تمام تغییرات حالت انجام شده در تراکنش را بازگردانی می‌کند. مشابه `require` است اما کنترل بیشتری ارائه می‌دهد.

می‌تواند:  
- با پیام خطای سفارشی،  
- یا با نوع خطای سفارشی استفاده شود.

اغلب برای سادگی `require` ترجیح داده می‌شود، اما `revert` بیانگرتر است و هنگام استفاده از خطاهای سفارشی ضروری است.

**مثال:**

~~~~plaintext
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();

    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Not enough Ether provided.");

        // معادل با require:
        require(
            amount <= msg.value / 2 ether,
            "Not enough Ether provided."
        );

        // اجرای خرید
    }

    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
~~~~

---

### `try/catch`

بلوک `try/catch` اجازه می‌دهد تا فراخوانی‌های امن به قراردادهای خارجی انجام شود و خطاهای احتمالی گرفته و مدیریت شوند. این بلوک می‌تواند سه نوع خطا را بگیرد:  
- `Error(string)` — ناشی از `revert` با پیام  
- `Panic(uint)` — ناشی از `assert` یا بررسی‌های داخلی کامپایلر  
- خطاهای بازگشتی (Fallback) — هر خطای پیش‌فرض گرفته شده با استفاده از `bytes`

**مثال:**

~~~~solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.1;

interface DataFeed {
    function getData(address token) external returns (uint value);
}

contract FeedConsumer {
    DataFeed feed;
    uint errorCount;

    function rate(address token) public returns (uint value, bool success) {
        require(errorCount < 10);

        try feed.getData(token) returns (uint v) {
            return (v, true);
        } catch Error(string memory) {
            errorCount++;
            return (0, false);
        } catch Panic(uint) {
            errorCount++;
            return (0, false);
        } catch (bytes memory) {
            errorCount++;
            return (0, false);
        }
    }
}
~~~~

---

## جدول خلاصه

| مکانیزم    | نوع خطا             | کاربرد                                     |
|------------|---------------------|--------------------------------------------|
| `require`  | `Error(string)`     | اعتبارسنجی ورودی، فراخوانی‌های خارجی       |
| `assert`   | `Panic(uint256)`    | نا‌متغیرهای داخلی، شرایط غیرممکن           |
| `revert`   | سفارشی یا رشته‌ای   | مدیریت خطای دستی، خطاهای سفارشی             |
| `try/catch`| خطا / Panic / بازگشتی| خطاهای تعامل با قراردادهای خارجی           |

---

## نکات

- `require` بهترین انتخاب برای چک‌های کاربر است.  
- `assert` باید برای منطق داخلی بحرانی استفاده شود.  
- `revert` کنترل دقیق‌تری برای سیگنال‌دهی خطا ارائه می‌کند.  
- `try/catch` برای قراردادهایی که ممکن است به صورت غیرمنتظره شکست بخورند مفید است.

# `try` / `catch` در Solidity

در Solidity، بلوک‌های `try`/`catch` برای مدیریت نرم خطاهایی که ممکن است هنگام فراخوانی قراردادهای خارجی رخ دهند، استفاده می‌شوند. این امکان باعث می‌شود قراردادها به دلیل مشکلات خارجی به طور کامل شکست نخورند و بتوانند اقدامات جایگزین مناسبی انجام دهند.

---

## هدف

مکانیزم `try`/`catch` امکان:  
- اجرای امن فراخوانی‌های خارجی  
- گرفتن و پاسخ به انواع مختلف خطاها  
- جلوگیری از بازگشت کل قرارداد در صورت شکست فقط یک فراخوانی خارجی  

را فراهم می‌کند.

---
## انواع خطاهایی که توسط try/catch گرفته می‌شوند

1. `Error(string)` – زمانی فعال می‌شود که `revert()` با یک رشته توضیحی فراخوانی شود.
2. `Panic(uint)` – برای مسائل بحرانی مانند سرریز محاسباتی یا خطای `assert` ایجاد می‌شود.
3. `bytes` – تمام خطاهای سطح پایین دیگر را شامل می‌شود، از جمله فراخوانی‌هایی بدون پیام بازگشتی.

---

## مثال: فراخوانی خارجی با مدیریت خطا

~~~~solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.1;

interface DataFeed {
    function getData(address token) external returns (uint value);
}

contract FeedConsumer {
    DataFeed feed;
    uint errorCount;

    function rate(address token) public returns (uint value, bool success) {
        // پس از 10 خطا، عملکرد به طور دائم غیرفعال می‌شود
        require(errorCount < 10);

        try feed.getData(token) returns (uint v) {
            return (v, true);
        } catch Error(string memory /*reason*/) {
            // زمانی فراخوانی می‌شود که revert() با رشته توضیحی فعال شود
            errorCount++;
            return (0, false);
        } catch Panic(uint /*errorCode*/) {
            // برای خطاهای بحرانی مانند تقسیم بر صفر یا سرریز
            errorCount++;
            return (0, false);
        } catch (bytes memory /*lowLevelData*/) {
            // برای هر خطای سطح پایین دیگر
            errorCount++;
            return (0, false);
        }
    }
}
~~~~

---

## نکات کلیدی

- بلوک `try` باید یک تابع خارجی را فراخوانی کند که مقدار بازمی‌گرداند.
- تمام قسمت‌های `catch` اختیاری هستند اما امکان مدیریت خطا در سطوح مختلف را می‌دهند.
- در داخل `try` می‌توان از `require()` برای بررسی‌های داخلی بیشتر استفاده کرد.
- در مثال بالا، متغیر `errorCount` به عنوان یک مکانیزم حفاظتی در برابر تکرار خطاهای خارجی استفاده شده است.

---

## موارد استفاده

از `try`/`catch` استفاده کنید زمانی که:
- در حال فراخوانی توابع از قراردادهای خارجی نامطمئن یا ناشناخته هستید.
- نمی‌خواهید کل تراکنش به خاطر یک خطای خارجی بازگردانده شود.
- نیاز به کنترل دقیق‌تر روی انواع مختلف خطا برای دیباگ یا عملکرد جایگزین دارید.

---

## خلاصه

مکانیزم `try`/`catch` باعث افزایش پایداری قراردادها می‌شود و امکان بازیابی از خطاهای خارجی را فراهم می‌کند. این قابلیت در برنامه‌هایی مانند جمع‌کننده‌های داده، اوراکل‌ها و پراکسی‌ها که به قراردادهای خارجی وابسته‌اند، بسیار مفید است.

---

# خطاهای سفارشی در Solidity

خطاهای سفارشی (Custom Errors) یک ویژگی جدید در Solidity هستند که مصرف گس را کاهش داده و خوانایی را در هنگام مدیریت شرایط استثنایی بهبود می‌بخشند. به جای استفاده از رشته‌های توضیحی در `revert()`، می‌توان از ساختارهای تعریف‌شده برای خطاها استفاده کرد.

---

## چرا از خطاهای سفارشی استفاده کنیم؟

- **کم‌هزینه از نظر گس**: به‌خصوص در قراردادهای پیچیده، مصرف گس کمتری دارند.
- **ساختارمند**: اطلاعات ساختاریافته درباره خطا ارائه می‌دهند.
- **خوانا**: نام خطا و پارامترهای آن منطق قرارداد را قابل درک‌تر می‌کنند.

---

## تعریف یک خطای سفارشی

خطا با استفاده از کلیدواژه `error` تعریف می‌شود و می‌توان آن را:
- در سطح قرارداد یا
- در سطح فایل به‌صورت سراسری تعریف کرد.

مثال:

~~~~solidity
error NotEnoughFunds(uint requested, uint available);
~~~~

در اینجا، یک خطا تعریف شده که دو عدد صحیح بدون علامت به عنوان آرگومان دریافت می‌کند.

---

## استفاده از خطاهای سفارشی با `revert`

برای فعال کردن خطای سفارشی از `revert` استفاده می‌شود.

### مثال: قرارداد توکن با خطای سفارشی

~~~~solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

error NotEnoughFunds(uint requested, uint available);

contract Token {
    mapping(address => uint) balances;

    function transfer(address to, uint amount) public {
        uint balance = balances[msg.sender];

        if (balance < amount)
            revert NotEnoughFunds(amount, balance);

        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
~~~~

در این مثال، اگر کاربر بیشتر از موجودی خود بخواهد انتقال دهد، خطای `NotEnoughFunds` با جزئیات مناسب فعال می‌شود.

---

## ویژگی‌های کلیدی

- **قابل اورراید یا بارگذاری مجدد نیستند**: نام خطاها باید یکتا باشند.
- **به ارث برده می‌شوند**: اگر یک قرارداد والد خطایی را تعریف کند، فرزندان نیز می‌توانند از آن استفاده کنند.
- **فقط در `revert` قابل استفاده هستند**: نمی‌توان آنها را خارج از `revert` ایجاد یا فعال کرد.

---

## خلاصه

خطاهای سفارشی جایگزینی بهتر، ارزان‌تر و واضح‌تر برای پیام‌های خطای مبتنی بر رشته هستند. برای قراردادهای پیچیده که نیاز به دیباگ دقیق بدون از دست دادن کارایی دارند، بسیار مناسب‌اند.

---

# حمله Reentrancy در Solidity

## مقدمه

Reentrancy (بازدرون‌یابی) یک آسیب‌پذیری امنیتی مهم در قراردادهای هوشمند اتریوم است. زمانی رخ می‌دهد که یک فراخوانی خارجی به یک قرارداد غیرقابل اعتماد، قبل از کامل شدن اجرای تابع جاری و قبل از به‌روزرسانی وضعیت داخلی، به قرارداد اصلی بازمی‌گردد.

---

## قیاس دنیای واقعی

فرض کنید به کارمند بانک می‌گویید که پول برداشت کنید:

1. **اول** پول نقد را به شما می‌دهد.
2. **بعد** موجودی حسابتان را به‌روزرسانی می‌کند.

اگر شما با نیت بد، بلافاصله قبل از مرحله دوم درخواست برداشت دیگری بدهید، سیستم هنوز موجودی قبلی را نمایش می‌دهد و شما می‌توانید بیش از موجودی واقعی خود برداشت کنید.

---

## چگونه در Solidity اتفاق می‌افتد؟

در Solidity، Reentrancy معمولاً زمانی رخ می‌دهد که:

- اتر را با `.call()` یا `.send()` به آدرس خارجی ارسال می‌کنید.
- با قراردادهایی تعامل دارید که دارای تابع `fallback` یا `receive` هستند.

اگر قرارداد دریافت‌کننده دارای منطق مخرب باشد، می‌تواند قبل از پایان اجرای تابع اصلی به آن بازگردد و از وضعیت داخلی که هنوز تغییر نکرده (مثل موجودی) سوءاستفاده کند.

---

## الگوی Checks-Effects-Interactions (بررسی–تأثیر–تعامل)

مکانیزم اصلی دفاعی در برابر Reentrancy این الگوست. طبق این روش:

1. **بررسی (Checks)**: تمام شرایط لازم را اعتبارسنجی کنید.
   - استفاده از `require`
   - کنترل دسترسی مانند `onlyOwner`
2. **تأثیر (Effects)**: متغیرهای داخلی را به‌روزرسانی کنید.
   - مثال: `balances[msg.sender] = 0;`
3. **تعامل (Interactions)**: فراخوانی‌های خارجی را انجام دهید.
   - مثال: `msg.sender.call{value: amount}("")`

### چرا این روش موثر است؟

با به‌روزرسانی وضعیت داخلی قبل از هرگونه فراخوانی خارجی، حتی اگر بازدرون‌یابی رخ دهد، مقادیر مهم (مثل موجودی کاربر) قبلاً به مقادیر ایمن تنظیم شده‌اند و امکان سوءاستفاده وجود ندارد.

---

## راهکارهای تکمیلی

- **پرداخت به‌صورت Pull**:
  - کاربران را وادار کنید که خودشان موجودی را برداشت کنند.
  - این روش تعامل با قرارداد را کاهش می‌دهد.

- **قفل‌های ضد بازدرون‌یابی (Reentrancy Guards)**:
  - استفاده از قفل (mutex) برای جلوگیری از اجرای هم‌زمان تابع.
  - مثال: استفاده از `nonReentrant` در OpenZeppelin.

---

## خلاصه

- Reentrancy به مهاجم امکان فراخوانی بازگشتی یک تابع و سوءاستفاده از وضعیت نهایی نشده را می‌دهد.
- همیشه از الگوی **Checks-Effects-Interactions** پیروی کنید.
- ترجیحاً پرداخت‌ها را به صورت **pull** انجام دهید.
- از **Reentrancy Guard** برای افزایش امنیت استفاده کنید.

با رعایت این اصول، توسعه‌دهندگان قراردادهای هوشمند می‌توانند به‌طور قابل توجهی ریسک حملات بازدرون‌یابی را کاهش دهند.

---

# الگوهای طراحی پایه

## 1. الگوهای کنترل دسترسی

کنترل دسترسی اساس توسعه قراردادهای هوشمند است تا مشخص شود چه کسی می‌تواند توابع خاص را فراخوانی کند یا عملیات حساس انجام دهد.

---

### Ownable

#### توضیح
- قرارداد دارای یک **مالک** (آدرس اتریومی) است که دارای امتیازات ویژه است.
- فقط مالک می‌تواند برخی توابع خاص را مانند برداشت وجه یا متوقف کردن قرارداد فراخوانی کند.

#### پیاده‌سازی
- معمولاً مالک در سازنده (`constructor`) مشخص می‌شود.
- از modifierهایی مانند `onlyOwner` برای محدود کردن دسترسی استفاده می‌شود.

#### مثال‌های کاربرد
- توابع مدیریتی
- مکانیزم توقف اضطراری
- مدیریت توزیع توکن یا ارتقاء قرارداد

#### کد نمونه
~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyContract is Ownable {
    function doSomethingCritical() public onlyOwner {
        // فقط مالک می‌تواند این را اجرا کند
    }
}
~~~~

---

### Pausable

#### توضیح
- به یک حساب مجاز (معمولاً مالک) اجازه می‌دهد تا قرارداد را **متوقف** و **فعال** کند.
- هنگام توقف، برخی توابع غیرفعال می‌شوند تا از قرارداد در برابر خطا یا حمله محافظت شود.

#### پیاده‌سازی
- از یک متغیر بولین `paused` استفاده می‌شود.
- modifierهایی مانند `whenNotPaused` و `whenPaused` ارائه می‌دهد.

#### مثال‌های کاربرد
- توقف انتقال توکن در صورت کشف باگ امنیتی
- توقف یک کمپین سرمایه‌گذاری در شرایط اضطراری

#### کد نمونه
~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol"; // اگر فقط مالک مجاز به توقف باشد

contract MyPausableContract is Pausable, Ownable {
    function transferTokens() public whenNotPaused {
        // منطق انتقال توکن
    }

    function pauseContract() public onlyOwner {
        _pause(); // ارث‌بری از Pausable
    }

    function unpauseContract() public onlyOwner {
        _unpause(); // ارث‌بری از Pausable
    }
}
~~~~



# 2. الگوهای ساختار داده

ذخیره‌سازی و بازیابی داده‌ها به‌صورت بهینه در زنجیره، برای ساخت قراردادهای هوشمند کارآمد و مقرون‌به‌صرفه ضروری است. این بخش ساختارهای داده متداول در Solidity و الگوهای آن‌ها را پوشش می‌دهد.

---

## Mapping

### توضیحات
- یک **فروشگاه کلید-مقدار**، مشابه هش‌مپ‌ها یا دیکشنری‌ها در سایر زبان‌های برنامه‌نویسی.
- بسیار کارآمد از نظر گاز برای جستجوها.
- قابلیت پیمایش مستقیم در زنجیره را ندارد (راه بومی برای فهرست کردن تمام کلیدها نیست).

### پیاده‌سازی

mapping(KeyType => ValueType) public myMap;

### نمونه‌های کاربردی
- ذخیره موجودی کاربران: `mapping(address => uint)`
- نسبت دادن ساختار داده کاربران به آدرس‌ها: `mapping(address => UserStruct)`
- پیگیری مالکیت NFT: `mapping(uint => address)`

## Struct و Array (با Mapping)

### توضیحات
- **Struct** امکان گروه‌بندی چند متغیر مرتبط را در یک نوع داده سفارشی می‌دهد.
- **Array** لیستی مرتب از آیتم‌ها را ذخیره می‌کند.
- اغلب همراه با Mapping استفاده می‌شود تا IDها یا آدرس‌ها به ساختار یا آرایه‌ها نسبت داده شوند.

### پیاده‌سازی

~~~~solidity
struct User {
    address userAddress;
    uint256 balance;
    bool isActive;
}

mapping(address => User) public users; // نگاشت آدرس به ساختار کاربر
uint256[] public userIds; // ذخیره لیستی از شناسه‌های کاربران
~~~~

### نمونه‌های کاربردی
- مدیریت لیستی از آیتم‌ها برای فروش
- پیگیری پروفایل‌های کاربران
- ذخیره پیشنهادات در قرارداد رأی‌گیری

## Enum (شمارنده)

### توضیحات
- نوع داده‌ای سفارشی که مجموعه‌ای ثابت از مقادیر را تعریف می‌کند.
- برای نمایش وضعیت‌های گسسته در یک قرارداد بسیار مفید است.

### پیاده‌سازی

enum State { Created, Active, Paused, Completed }

### نمونه‌های کاربردی
- وضعیت‌های گردش‌کار مثل کمپین‌های تأمین مالی: `Pending -> Active -> Successful -> Failed`
- نمایش وضعیت یا مرحله بازی‌ها

# 3. الگوهای امنیتی

الگوهای امنیتی به محافظت از قراردادهای هوشمند در برابر آسیب‌پذیری‌ها و حملات رایج کمک می‌کنند.

---

## Checks-Effects-Interactions (بررسی‌ها - تغییرات - تعاملات)

### توضیحات
- الگویی حیاتی برای جلوگیری از **حملات Re-entrancy** (ورود مجدد).
- ترتیبی خاص از اجرای توابع را اعمال می‌کند:
  1. **بررسی‌ها**: تأیید شرایط (مثل `require` یا محدودکننده‌های دسترسی).
  2. **تغییرات**: به‌روزرسانی وضعیت داخلی قرارداد.
  3. **تعاملات**: تماس با قراردادهای خارجی یا ارسال اتر.

### پیاده‌سازی
- همیشه ابتدا بررسی‌ها را انجام دهید.
- متغیرهای حالت را قبل از هر تماس خارجی به‌روزرسانی کنید.
- در پایان، با قراردادهای خارجی تعامل کنید یا اتر ارسال کنید.

### نمونه کاربرد
- هر تابعی که اتر ارسال می‌کند یا با قرارداد دیگر تعامل دارد.

## پرداخت Pull به‌جای Push (الگوی برداشت)

### توضیحات
- به‌جای **فشار (Push)** اتر مستقیم به کاربران (که در صورت دریافت توسط قرارداد، خطر Re-entrancy دارد)، اجازه دهید کاربران با فراخوانی تابع `withdraw()`، وجوه خود را **برداشت (Pull)** کنند.

### پیاده‌سازی
- موجودی کاربران را در Mapping پیگیری کنید.
- کاربران تابع `withdraw()` را برای برداشت وجوه خود صدا می‌زنند.

### نمونه‌های کاربردی
- پلتفرم‌های جذب سرمایه، پرداخت حقوق، بازپرداخت‌ها

### قطعه کد

~~~~solidity
mapping(address => uint256) public balances;

function deposit() public payable {
    balances[msg.sender] += msg.value;
}

function withdraw() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0, "No funds to withdraw");

    balances[msg.sender] = 0; // اثر: اول موجودی را پاک کن!
    (bool success, ) = payable(msg.sender).call{value: amount}(""); // تعامل
    require(success, "Withdrawal failed");
}
~~~~

## محافظ Re-entrancy

### توضیحات
- یک مکانیزم صریح برای جلوگیری از ورود مجدد با استفاده از قفل Mutex.
- قرارداد `ReentrancyGuard` از OpenZeppelin یک modifier به نام `nonReentrant` برای محافظت از توابع فراهم می‌کند.

### پیاده‌سازی

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyGuardedContract is ReentrancyGuard {
    mapping(address => uint256) public balances;

    function withdraw() public nonReentrant {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No funds to withdraw");

        balances[msg.sender] = 0;
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Withdrawal failed");
    }
}
~~~~

# 4. الگوهای تعامل قرارداد

## هدف

نحوه تعامل قراردادها با سایر قراردادها یا مدیریت اتر ورودی.

---

## Interface (واسط)

### توضیحات

Interfaceها توابع خارجی قراردادی را که می‌خواهید با آن تعامل داشته باشید تعریف می‌کنند. مشابه کلاس‌های abstract یا interface در زبان‌های سنتی هستند.

### پیاده‌سازی

~~~~solidity
interface IAnotherContract {
    function someFunction() external returns (uint256);
}
~~~~

### نمونه‌های کاربردی

- تعامل با قرارداد ERC-20
- صدا زدن Oracle در Chainlink
- دسترسی به هر قرارداد مستقرشده از طریق API خارجی

## توابع `receive()` و `fallback()`

### توضیحات

توابع خاصی برای دریافت اتر ورودی و تماس‌های نامعتبر:

- `receive()`: هنگام انتقال ساده اتر (بدون دیتا) اجرا می‌شود. باید `payable` و `external` باشد.
- `fallback()`: زمانی اجرا می‌شود که هیچ تابعی با نام فراخوانی مطابقت نداشته باشد یا اگر اتر با دیتا ارسال شود ولی تابع متناظری نباشد. برای پذیرش اتر باید `payable` و `external` باشد.

### پیاده‌سازی

~~~~solidity
receive() external payable {
    // منطق هنگام دریافت ETH بدون دیتا
}

fallback() external payable {
    // منطق هنگام دریافت ETH با دیتا یا عدم وجود تابع منطبق
}
~~~~

### نمونه‌های کاربردی

- پذیرش ETH در قرارداد (مثلاً برای کمک مالی)
- مکانیزم کلی برای تماس‌های غیرمنتظره یا عمومی
- پشتیبانی از الگوهای پروکسی یا قراردادهای قابل ارتقاء

# 5. الگوهای مدیریت خطا

**هدف:** فراهم کردن بازخورد شفاف هنگام شکست عملیات.

## require(), revert(), assert()

### توضیحات

- **require()**  
  برای بررسی ورودی‌ها و وضعیت قرارداد استفاده می‌شود. در صورت نادرستی شرط، تراکنش revert شده و گاز مصرف‌نشده بازگردانده می‌شود.  
  کاربردهای رایج:
  - بررسی ورودی توابع
  - اعتبارسنجی مجوزها
  - اطمینان از پیش‌شرط‌ها

- **revert()**  
  به‌صورت صریح تراکنش را لغو می‌کند و می‌تواند پیام خطا ارائه دهد. مناسب برای شرایط پیچیده که `require()` کافی نیست.

- **assert()**  
  برای بررسی شرایط داخلی استفاده می‌شود که **هرگز** نباید نقض شوند. در صورت شکست، **تمام** گاز باقیمانده مصرف می‌شود. برای بررسی باگ‌های جدی ایده‌آل است.

### نمونه‌های کاربردی

~~~~solidity
require(msg.sender == owner, "Not authorized");
require(amount > 0, "Amount must be positive");
~~~~

---

# 6. الگوهای ایجاد و مدیریت قرارداد

## هدف

مدیریت استقرار و بازیابی چندین نمونه از قراردادها یا خدمات خارجی.

---

## الگوی Factory

### توضیحات

قراردادی که وظیفه ساخت و استقرار نمونه‌های جدید از قراردادهای دیگر را دارد. این الگو امکان ساخت کنترل‌شده و قابل پیگیری چندین قرارداد یکسان را فراهم می‌کند.

### پیاده‌سازی

از کلمه کلیدی `new` برای استقرار قرارداد استفاده می‌شود. همچنین می‌توان از `create2` برای آدرس‌های قابل پیش‌بینی استفاده کرد.

### نمونه‌های کاربردی

- ایجاد مجموعه NFT جدید ERC-721 برای هر کاربر.
- استقرار قرارداد جدید برای استخر نقدینگی هر جفت توکن (مثل Uniswap).
- ساخت نمونه‌های بازی یا صندوق اختصاصی برای کاربران.

### قطعه کد

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// قراردادی که کارخانه آن را ایجاد خواهد کرد
contract MyChildContract {
    address public creator;
    string public name;

    constructor(string memory _name) {
        creator = msg.sender;
        name = _name;
    }
}

contract MyFactory {
    // رویداد برای ثبت ایجاد قراردادهای جدید
    event ChildContractCreated(address indexed childAddress, address indexed creator, string name);

    // ذخیره قراردادهای ایجادشده (اختیاری ولی مفید)
    address[] public deployedContracts;

    function createChildContract(string memory _name) public returns (address newContractAddress) {
        MyChildContract newChild = new MyChildContract(_name);
        newContractAddress = address(newChild);

        deployedContracts.push(newContractAddress);
        emit ChildContractCreated(newContractAddress, msg.sender, _name);
    }
}
~~~~



## الگوی رجیستری (Registry Pattern)

### توضیح

یک قرارداد مرکزی که فهرستی از آدرس‌ها (مثلاً آدرس سایر قراردادها، آدرس کاربران یا نقاط انتهایی سرویس‌ها) و احتمالاً متادیتای مرتبط با آن‌ها را ذخیره و مدیریت می‌کند. این قرارداد مانند یک سرویس جستجو عمل می‌کند.

### پیاده‌سازی

معمولاً از `mapping(keyType => valueType)` استفاده می‌شود، که در آن `valueType` اغلب یک آدرس یا یک ساختار `struct` شامل آدرس و اطلاعات دیگر است. اغلب با `Ownable` ترکیب می‌شود تا مدیریت قرارداد فقط در اختیار مالک باشد.

### مثال کاربردی

- نگاشت نام‌های قابل خواندن توسط انسان به آدرس قراردادها (مانند ENS، اما ساده‌تر).
- نگهداری فهرستی از آدرس‌های تاییدشده یا سفید برای عملیات خاص.
- یک فهرست مرکزی برای یافتن نسخه‌های مختلف قراردادهای یک پروتکل.
- ثبت و کشف سرویس‌ها در یک dApp چندقراردادی.

### قطعه کد

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract ContractRegistry is Ownable {
    // نگاشت نام‌ها به آدرس قراردادها
    mapping(bytes32 => address) public registeredContracts; // استفاده از bytes32 برای کلیدهای با اندازه ثابت

    // رویداد برای ثبت لاگ ثبت‌نام‌ها
    event ContractRegistered(bytes32 indexed nameHash, address indexed contractAddress, string name);

    function registerContract(string memory _name, address _contractAddress) public onlyOwner {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        require(registeredContracts[nameHash] == address(0), "Contract already registered");
        require(_contractAddress != address(0), "Invalid contract address");

        registeredContracts[nameHash] = _contractAddress;
        emit ContractRegistered(nameHash, _contractAddress, _name);
    }

    function getContractAddress(string memory _name) public view returns (address) {
        bytes32 nameHash = keccak256(abi.encodePacked(_name));
        return registeredContracts[nameHash];
    }

    // می‌توان توابع به‌روزرسانی/لغو ثبت را نیز اضافه کرد که فقط توسط مالک قابل اجرا باشند
}
~~~~

---

# ۶. الگوهای ادغام داده‌های خارجی

**هدف:** آوردن داده‌های واقعی یا خارج از زنجیره (off-chain) به‌صورت ایمن به بلاکچین برای اجرای قراردادهای هوشمند.

## الگوی اوراکل (Oracle Pattern)

### توضیح

**الگوی اوراکل** یک استراتژی طراحی است که امکان دسترسی قراردادهای هوشمند به اطلاعات خارجی (خارج از زنجیره) را فراهم می‌کند. این اطلاعات می‌توانند شامل قیمت دارایی‌ها، داده‌های آب‌وهوا، نتایج ورزشی، اعداد تصادفی و غیره باشند.

قراردادهای هوشمند ذاتاً قطعی (deterministic) و ایزوله هستند، یعنی نمی‌توانند مستقیماً با APIها یا دنیای بیرون ارتباط برقرار کنند. اوراکل‌ها به‌عنوان پل بین بلاکچین و منابع داده خارجی عمل می‌کنند و دسترسی امن و غیرقابل اعتماد به اطلاعات واقعی را فراهم می‌کنند.

### پیاده‌سازی

دو روش اصلی برای پیاده‌سازی اوراکل‌ها وجود دارد:

#### ۱. اوراکل متمرکز (برای آموزش و نمونه‌سازی)

- یک شخص معتمد (معمولاً مالک قرارداد یا مدیر شناخته‌شده) به‌صورت دستی داده‌ها را وارد قرارداد می‌کند.
- مناسب برای تست، dAppهای ساده یا محیط‌هایی که منبع داده قابل اعتماد است.
- از امنیت کمتری برخوردار است زیرا به یک نقطه شکست و صداقت تامین‌کننده داده وابسته است.

#### ۲. اوراکل غیرمتمرکز (مثلاً Chainlink)

- یک شبکه غیرمتمرکز از نودهای اوراکل برای واکشی و تجمیع داده‌های خارجی استفاده می‌شود.
- داده‌ها را به‌صورت مقاوم در برابر دستکاری، قابل تأیید و بدون نیاز به اعتماد فراهم می‌کند.
- معمولاً در DeFi، بازی‌ها و بیمه‌های در سطح تولید مورد استفاده قرار می‌گیرد.
- Chainlink پرکاربردترین ارائه‌دهنده اوراکل غیرمتمرکز است.

### مثال‌های کاربردی

- **DeFi:** واکشی قیمت دارایی‌ها در زمان واقعی برای وام‌دهی، وام‌گیری یا دارایی‌های مصنوعی.
- **بازارهای پیش‌بینی:** تعیین نتایج رویدادهای واقعی مانند انتخابات یا مسابقات ورزشی.
- **بیمه:** فعال‌سازی پرداخت‌ها بر اساس رویدادهای واقعی قابل تأیید (مثلاً بارندگی، تأخیر پرواز).
- **بازی‌ها:** ارائه اعداد تصادفی یا تأیید وضعیت بازی خارج از زنجیره.

### قطعه کد

~~~~solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/access/Ownable.sol";

contract SimplePriceOracle is Ownable {
    uint256 public ethPriceUsd; // به سنت ذخیره می‌شود. مثلا $2000.00 برابر 200000 است

    event PriceUpdated(uint256 newPrice, uint256 timestamp);

    // فقط مالک (نهاد قابل اعتماد) می‌تواند قیمت را به‌روزرسانی کند
    function updateEthPrice(uint256 _newPrice) public onlyOwner {
        require(_newPrice > 0, "Price must be positive");
        ethPriceUsd = _newPrice;
        emit PriceUpdated(_newPrice, block.timestamp);
    }

    function getEthPrice() public view returns (uint256) {
        return ethPriceUsd;
    }

    // **در کاربرد واقعی، باید با Chainlink یا مشابه آن یکپارچه شود**
    // مثال (مفهومی، قابل اجرا نیست بدون قرارداد Chainlink):
    // import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
    // AggregatorV3Interface internal priceFeed;
    // constructor() {
    //     priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419); // Mainnet ETH/USD
    // }
    // function getLatestPriceFromChainlink() public view returns (int256) {
    //     ( , int256 price, , , ) = priceFeed.latestRoundData();
    //     return price;
    // }
}
~~~~

# ۷. الگوهای سازوکار مالی و انگیزشی

**هدف:** پیاده‌سازی مکانیزم‌هایی برای قفل کردن دارایی‌ها، توزیع پاداش‌ها یا مدیریت سرمایه‌های مشترک.

## الگوی استیکینگ (Staking Pattern)

### توضیح

**الگوی استیکینگ** یک طراحی قرارداد هوشمند است که به کاربران امکان می‌دهد توکن‌های خود (معمولاً ERC-20) را در قرارداد قفل کنند و در ازای آن به‌مرور زمان پاداش دریافت کنند. این یک سازوکار پایه در اپلیکیشن‌های بلاکچینی مانند اجماع اثبات سهام (PoS)، فارمینگ سود (Yield Farming) و حاکمیت غیرمتمرکز است.

کاربران برای نگهداری و استیک توکن‌های خود پاداش دریافت می‌کنند، به‌طوری‌که میزان و مدت زمان استیک کردن در مقدار پاداش موثر است. این الگو باعث مشارکت بلندمدت و هم‌راستایی با موفقیت پروتکل می‌شود.

### پیاده‌سازی

یک قرارداد استیکینگ معمولی شامل مؤلفه‌های زیر است:

#### ۱. سپرده‌گذاری توکن‌ها

- کاربران باید ابتدا با استفاده از `IERC20.approve` اجازه انتقال توکن توسط قرارداد را صادر کنند.
- سپس توکن‌ها از طریق `transferFrom` یا تابعی سفارشی واریز می‌شوند.

#### ۲. ردیابی وضعیت

- قرارداد نگاشت‌هایی مانند موارد زیر را نگه می‌دارد:
  - `balances`: مقدار توکن‌های استیک شده هر کاربر.
  - `userRewardPerTokenPaid`: آخرین پاداش به‌ازای هر توکن پرداخت‌شده به کاربر.
  - `rewards`: مجموع پاداش‌های ذخیره‌شده برای هر کاربر.

مثال:
```solidity
mapping(address => uint256) public balances;
mapping(address => uint256) public rewards;
mapping(address => uint256) public userRewardPerTokenPaid;
```

#### ۳. محاسبه پاداش

- تکنیکی رایج استفاده از **انباشتگر پاداش به ازای هر توکن** است:
  - `rewardPerTokenStored` پاداش تجمعی پرداخت‌شده به ازای هر توکن است.
  - هنگام تعامل کاربران (استیک، برداشت یا دریافت پاداش)، سهم پاداش آن‌ها بر اساس زمان گذشته به‌روز می‌شود.

متغیرهای کلیدی:
```solidity
uint256 public rewardPerTokenStored;
uint256 public lastUpdateTime;
```

- پاداش‌های در حال انتظار کاربران با استفاده از فرمول زیر به‌روزرسانی می‌شوند:
```solidity
earned = balance * (rewardPerToken - userRewardPerTokenPaid) + rewards[user];
```

#### ۴. برداشت / دریافت پاداش

- کاربران می‌توانند:
  - توکن‌های استیک شده را برداشت کنند (معمولاً پس از یک دوره قفل یا هر زمان، بسته به طراحی).
  - پاداش‌های انباشته را با یک تابع جداگانه مانند `getReward()` دریافت کنند.

#### ۵. توزیع پاداش

- پاداش‌ها می‌توانند به‌صورت پیش‌پرداخت یا به‌مرور زمان منتقل شوند.
- برخی قراردادها به یک `RewardDistributor` خارجی برای ارسال دوره‌ای توکن‌ها متکی هستند.
- پاداش‌ها معمولاً بر اساس مقدار و زمان استیک به‌صورت نسبی توزیع می‌شوند.

### مثال‌های کاربردی

- **Yield Farming:** کاربران توکن‌های LP را استیک می‌کنند تا توکن‌های پاداش دریافت کنند و به تأمین نقدینگی تشویق شوند.
- **اثبات سهام:** اعتبارسنج‌ها توکن‌ها را برای امنیت شبکه قفل می‌کنند و در ازای مشارکت صادقانه پاداش می‌گیرند.
- **حاکمیت:** قدرت رأی‌دهی بر اساس میزان توکن‌های استیک شده است.
- **سپرده‌گذاری مدت‌دار:** کاربران سرمایه را برای مدت معین قفل می‌کنند و در ازای آن سود ثابت یا متغیر دریافت می‌کنند.




</div>
